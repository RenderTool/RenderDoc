import{_ as p,r as l,o as d,c as u,d as s,w as e,a,b as n,e as i}from"./app-a799a61c.js";const g="/RenderDoc/assets/shader-242c492e.jpg",m="/RenderDoc/assets/reducehp-04c5bd6c.jpg",f="/RenderDoc/assets/currenthp-245220ec.jpg",_="/RenderDoc/assets/hp3333-e2e485b3.jpg",b="/RenderDoc/assets/jizhixiugai -2cb6ee49.jpg",h="/RenderDoc/assets/dehp-190376bc.jpg",v="/RenderDoc/assets/dshp2-adcd3258.jpg",k="/RenderDoc/assets/hpbadi-99e5adca.png",x="/RenderDoc/assets/hpall-3904efd1.jpg",j="/RenderDoc/assets/blooad-423b242a.jpg",W="/RenderDoc/assets/hpshow-ea0a685d.jpg",y="/RenderDoc/assets/hppart1-9fbe8b53.png",R="/RenderDoc/assets/standmat-e30de3bd.png",q="/RenderDoc/assets/czy-07290e98.png",z="/RenderDoc/assets/hpvs-7f25fe34.png",L="/RenderDoc/assets/drawline-84ccdd09.png",D="/RenderDoc/assets/hpfanan2-5877bc65.png",C="/RenderDoc/assets/drawlinefunction-faae0829.png",w="/RenderDoc/assets/TEXCOORD-84367a2b.png",V="/RenderDoc/assets/color1-5a237a72.png",U="/RenderDoc/assets/rgb-6b26202f.png",S="/RenderDoc/assets/colormap-92695667.png",B="/RenderDoc/assets/UVTEXCOORD-f876536e.png",O="/RenderDoc/assets/commask-a42c35e5.jpg",c="/RenderDoc/assets/TEXCOORDCOMB-a00fb5ae.jpg",E="/RenderDoc/assets/x_0.25-c37ae28f.png",N="/RenderDoc/assets/fracnode-a5f00c7b.png",I="/RenderDoc/assets/repeat-4ef04480.png",P="/RenderDoc/assets/zb-a66841bd.png",G="/RenderDoc/assets/pct-efc6d175.png",T="/RenderDoc/assets/hpzbi-f974c7ef.png",A="/RenderDoc/assets/hppct2-6f9690f9.jpg",H="/RenderDoc/assets/OWHP1-04cf5279.png",M="/RenderDoc/assets/finmask-5ba186f0.png",F="/RenderDoc/assets/clamprange-ee90944e.png",X="/RenderDoc/assets/custom-7b355c2f.png",Y="/RenderDoc/assets/jdian111-56ac1894.png",J="/RenderDoc/assets/remap-c639b3a0.png",K="/RenderDoc/assets/remapnode-5ef26711.png",Q="/RenderDoc/assets/blooad2-8be5aa65.jpg",Z="/RenderDoc/assets/bp233-4174c05e.png",$="/RenderDoc/assets/hpzt2-ce69b8c9.jpg",aa="/RenderDoc/assets/hptest-11cc74d0.png",na="/RenderDoc/assets/hptime-1bed1009.jpg",sa="/RenderDoc/assets/linear-7c3b5d3c.png",ta="/RenderDoc/assets/linspace-3d32104a.png",ea="/RenderDoc/assets/linespacevssrgb-300958a3.png",ia="/RenderDoc/assets/linshow-74b6950a.png",oa="/RenderDoc/assets/Ceil-426f1f6b.png",la="/RenderDoc/assets/bloodnew-7a06ad54.jpg",ra="/RenderDoc/assets/blooadnewue5-80f020c7.png",ca="/RenderDoc/assets/spacenew-59606220.png",pa="/RenderDoc/assets/hpbarnor-23fd5e68.png",da="/RenderDoc/assets/CURRENT-7dbd3916.png",ua="/RenderDoc/assets/lerp-fe79aa9f.png",ga="/RenderDoc/assets/lerphp-eca47c71.png",ma={},fa=a("h2",{id:"导读",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#导读","aria-hidden":"true"},"#"),n(" 导读")],-1),_a=a("figure",null,[a("img",{src:g,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),ba=a("figure",null,[a("img",{src:m,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),ha=a("hr",null,null,-1),va=a("figure",null,[a("img",{src:f,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),ka=a("hr",null,null,-1),xa=a("figure",null,[a("img",{src:_,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),ja=a("hr",null,null,-1),Wa=a("figure",null,[a("img",{src:b,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),ya=a("figure",null,[a("img",{src:h,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Ra=a("figure",null,[a("img",{src:v,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),qa=a("figure",null,[a("img",{src:k,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),za=a("figure",null,[a("img",{src:x,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),La=a("figure",null,[a("img",{src:j,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Da=a("h2",{id:"格子部分-方案1",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#格子部分-方案1","aria-hidden":"true"},"#"),n(" 格子部分（方案1）")],-1),Ca=a("figure",null,[a("img",{src:W,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),wa=a("figure",null,[a("img",{src:y,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Va=a("figure",null,[a("img",{src:R,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Ua=a("figure",null,[a("img",{src:q,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Sa=a("figure",null,[a("img",{src:z,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Ba=a("p",null,[n("也就是说问题变成怎么保证线条不变就行了，那么我想到一个"),a("code",null,"drawline"),n("的节点可以画线。")],-1),Oa=a("figure",null,[a("img",{src:L,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Ea=a("figure",null,[a("img",{src:D,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Na=a("figure",null,[a("img",{src:C,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Ia=a("h3",{id:"texcoord",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#texcoord","aria-hidden":"true"},"#"),n(" TEXCOORD")],-1),Pa=a("div",{class:"hint-container note"},[a("p",{class:"hint-container-title"},"注"),a("p",null,"TEXCOORD（Texture Coordinates）节点通常用于处理纹理坐标。纹理坐标是指在纹理映射过程中，用于确定在纹理图像上的哪个位置获取颜色的坐标。 也称为UV坐标。")],-1),Ga=a("ol",null,[a("li",null,"UE中贴图的左上角为原点（0.0,0.0）,右下角是（1.0，1.0）"),a("li",null,"垂直方向是Y轴，水平方向是X轴。")],-1),Ta=a("figure",null,[a("img",{src:w,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Aa=i('<h3 id="colormap" tabindex="-1"><a class="header-anchor" href="#colormap" aria-hidden="true">#</a> ColorMap</h3><div class="hint-container note"><p class="hint-container-title">注</p><p>Colormap（色彩映射）是用于将数据值映射到颜色的方法。</p></div><figure><img src="'+V+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>在UE中，颜色贴图通常采用RGBA的格式，即红色（R），绿色（G），蓝色（B）和Alpha通道（A）。每个通道的含义如下：</p></blockquote><figure><img src="'+U+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><p><strong>红色通道（R）：</strong></p><ul><li><strong>含义：</strong> 红色通道表示颜色的红色分量。</li><li><strong>用途：</strong> 红色通道通常用于表示表面的反射率，金属度（Metallic）等属性。</li></ul></li><li><p><strong>绿色通道（G）：</strong></p><ul><li><strong>含义：</strong> 绿色通道表示颜色的绿色分量。</li><li><strong>用途：</strong> 绿色通道通常用于表示表面的粗糙度（Roughness）等属性。</li></ul></li><li><p><strong>蓝色通道（B）：</strong></p><ul><li><strong>含义：</strong> 蓝色通道表示颜色的蓝色分量。</li><li><strong>用途：</strong> 蓝色通道通常用于表示表面的法线贴图或其他法线信息。</li></ul></li><li><p><strong>Alpha通道（A）：</strong></p><ul><li><strong>含义：</strong> Alpha通道表示颜色的透明度或不透明度。0表示完全透明，1表示完全不透明。</li><li><strong>用途：</strong> Alpha通道通常用于在材质中控制透明度，例如实现半透明效果、蒙皮遮罩等。</li></ul></li></ol>',6),Ha=a("figure",null,[a("img",{src:S,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Ma=a("h3",{id:"componentmask节点",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#componentmask节点","aria-hidden":"true"},"#"),n(" ComponentMask节点")],-1),Fa=a("p",null,[n("记得我们提到过的"),a("code",null,"TexCoord"),n("节点吗？他代表着UV纹理坐标，我们可以通过"),a("code",null,"ComponentMask"),n("节点提取坐标。")],-1),Xa=a("figure",null,[a("img",{src:B,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Ya=a("figure",null,[a("img",{src:O,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Ja=a("p",null,[n("通过独立的R和G各自对应X和Y方向的颜色信息，从而揭开"),a("code",null,"TexCoord"),n("的庐山真面目")],-1),Ka=a("figure",null,[a("img",{src:c,alt:"两个衰减贴图对应到R和G合成",tabindex:"0",loading:"lazy"}),a("figcaption",null,"两个衰减贴图对应到R和G合成")],-1),Qa=a("h3",{id:"if节点",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#if节点","aria-hidden":"true"},"#"),n(" IF节点")],-1),Za=a("p",null,[n("接着，我们可以利用"),a("code",null,"IF"),n("节点来格式化我们的纹理贴图")],-1),$a=i('<figure><img src="'+E+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>tex<span class="token punctuation">.</span>x <span class="token operator">&gt;=</span> <span class="token number">0.25</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">float3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//红色</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token function">float3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//白色</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>0-0.25的部分都是红色</li><li>0.25-1.0的部分都是白色</li></ol><h3 id="frac节点" tabindex="-1"><a class="header-anchor" href="#frac节点" aria-hidden="true">#</a> Frac节点</h3><figure><img src="`+N+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',5),an=a("p",null,[n("然后，我们可以利用"),a("code",null,"Frac"),n("节点来平铺我们的贴图。")],-1),nn=a("figure",null,[a("img",{src:I,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),sn=a("h3",{id:"tiling平铺",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#tiling平铺","aria-hidden":"true"},"#"),n(" tiling平铺")],-1),tn=a("figure",null,[a("img",{src:P,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),en=a("div",{class:"hint-container note"},[a("p",{class:"hint-container-title"},"注"),a("p",null,"循环单元，这里不是上下左右循环拼接的循环，而是指原本贴图平铺=1时的部分为循环单元。")],-1),on=a("figure",null,[a("img",{src:G,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),ln=a("ol",null,[a("li",null,[a("p",null,[n("最终显示=（颜色1占比+颜色2占比）x 平铺次数 "),a("br"),n("其中颜色1占比+颜色2占比 =1")])]),a("li",null,[a("p",null,"比如（0.5+0.5）x平铺2次，此时每个独立颜色1占总图1/4")])],-1),rn=a("figure",null,[a("img",{src:T,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),cn=a("figure",null,[a("img",{src:A,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),pn=a("figure",null,[a("img",{src:H,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),dn=a("figure",null,[a("img",{src:M,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),un=a("figure",null,[a("img",{src:F,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),gn=i('<h3 id="custom节点" tabindex="-1"><a class="header-anchor" href="#custom节点" aria-hidden="true">#</a> Custom节点</h3><figure><img src="'+X+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 1. 总血量Maximums = 一个格子血量PerSplitHP * 格子数量CellCount</span>
<span class="token keyword">float</span> CellCount <span class="token operator">=</span> Maximums <span class="token operator">/</span> PerSplitHP<span class="token punctuation">;</span>

<span class="token comment">// 2. 如果格子数量CellCount = 1 返回 0。</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>CellCount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 3. 绘制格子</span>
float2 tex <span class="token operator">=</span> <span class="token function">frac</span><span class="token punctuation">(</span><span class="token function">float2</span><span class="token punctuation">(</span>UV<span class="token punctuation">.</span>x <span class="token operator">*</span> CellCount<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 4. 计算间隔宽度</span>

<span class="token keyword">float</span> Compensate <span class="token operator">=</span> CellCount <span class="token operator">*</span> SpacingValue<span class="token punctuation">;</span><span class="token comment">//补偿</span>

<span class="token keyword">float</span> Spacing <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span>Compensate<span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">0.99</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//钳制在0.01-0.99内</span>


<span class="token comment">// 5. 检查是否在间隔范围内</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>tex<span class="token punctuation">.</span>x <span class="token operator">&gt;=</span> Spacing<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+Y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',4),mn=a("h3",{id:"remap节点",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#remap节点","aria-hidden":"true"},"#"),n(" remap节点")],-1),fn=a("figure",null,[a("img",{src:J,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),_n=a("div",{class:"hint-container note"},[a("p",{class:"hint-container-title"},"注"),a("figure",null,[a("img",{src:K,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")]),a("p",null,"将一个范围的值映射到另一个范围，比如0-100映射到0-1，同时起着钳制作用。")],-1),bn=a("figure",null,[a("img",{src:Q,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),hn=a("figure",null,[a("img",{src:Z,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),vn=a("h3",{id:"临界值问题",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#临界值问题","aria-hidden":"true"},"#"),n(" 临界值问题")],-1),kn=a("figure",null,[a("img",{src:$,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),xn=a("figure",null,[a("img",{src:aa,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),jn=a("figure",null,[a("img",{src:na,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Wn=a("h2",{id:"格子部分-方案2",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#格子部分-方案2","aria-hidden":"true"},"#"),n(" 格子部分（方案2）")],-1),yn=a("figure",null,[a("img",{src:c,alt:"两个衰减贴图对应到R和G合成",tabindex:"0",loading:"lazy"}),a("figcaption",null,"两个衰减贴图对应到R和G合成")],-1),Rn=a("h3",{id:"linegradient节点",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#linegradient节点","aria-hidden":"true"},"#"),n(" LineGradient节点")],-1),qn=a("figure",null,[a("img",{src:sa,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),zn=a("figure",null,[a("img",{src:ta,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Ln=a("figure",null,[a("img",{src:ea,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Dn=a("iframe",{src:"//player.bilibili.com/player.html?aid=38607808&bvid=BV15t411Y7cf&cid=67867798&p=1",scrolling:"no",border:"0",frameborder:"no",framespacing:"0",allowfullscreen:"true",width:"100%",height:"500"}," ",-1),Cn=a("figure",null,[a("img",{src:ia,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),wn=i('<h3 id="ceil节点" tabindex="-1"><a class="header-anchor" href="#ceil节点" aria-hidden="true">#</a> Ceil节点</h3><figure><img src="'+oa+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container note"><p class="hint-container-title">注</p><p>&quot;ceil&quot; 是 &quot;ceiling&quot;（天花板）的缩写，通常指向向上取整的操作。</p></div>',3),Vn=a("figure",null,[a("img",{src:la,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Un=a("figure",null,[a("img",{src:ra,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Sn=i('<figure><img src="'+ca+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 1. 总血量Maximums = 一个格子血量PerSplitHP * 格子数量CellCount</span>
<span class="token keyword">float</span> CellCount <span class="token operator">=</span> Maximums <span class="token operator">/</span> PerSplitHP<span class="token punctuation">;</span>

<span class="token comment">// 2. 如果格子数量CellCount = 1 返回 0。</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>CellCount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 3.frac贴图平铺CellCount次</span>

float2 tex <span class="token operator">=</span> <span class="token function">frac</span><span class="token punctuation">(</span><span class="token function">float2</span><span class="token punctuation">(</span>UV<span class="token punctuation">.</span>x<span class="token operator">*</span>CellCount<span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//4.计算补偿</span>
<span class="token keyword">float</span> Compensate <span class="token operator">=</span> CellCount <span class="token operator">*</span> SpacingValue<span class="token punctuation">;</span> <span class="token comment">// 补偿</span>

<span class="token comment">//5.依然需要钳制</span>
<span class="token keyword">float</span> Spacing <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span>Compensate<span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">0.99</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 钳制在0.001-0.99内</span>

<span class="token comment">//6.计算 tex.x 的偏移</span>
tex<span class="token punctuation">.</span>x <span class="token operator">+=</span><span class="token punctuation">(</span><span class="token operator">-</span>Spacing<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 7. 对 tex.x 进行 ceil 处理</span>
tex<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> tex<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">//tex.x = 1-(Sharpness*(1 - tex.x)); //虚化节点官方推荐512</span>

<span class="token keyword">return</span> tex<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="状态部分" tabindex="-1"><a class="header-anchor" href="#状态部分" aria-hidden="true">#</a> 状态部分</h2>`,3),Bn=a("figure",null,[a("img",{src:pa,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),On=a("figure",null,[a("img",{src:da,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),En=i('<h3 id="lerp节点" tabindex="-1"><a class="header-anchor" href="#lerp节点" aria-hidden="true">#</a> Lerp节点</h3><figure><img src="'+ua+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container note"><p class="hint-container-title">注</p><p>Lerp 的作用是在两个值之间按照线性关系产生一个中间值。</p></div><figure><img src="'+ga+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',4),Nn=a("h2",{id:"参考",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#参考","aria-hidden":"true"},"#"),n(" 参考")],-1),In={href:"https://learn.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-pguide",target:"_blank",rel:"noopener noreferrer"},Pn={href:"https://zhuanlan.zhihu.com/p/139665164",target:"_blank",rel:"noopener noreferrer"};function Gn(Tn,An){const t=l("chatmessage"),o=l("gifwithbutton"),r=l("ExternalLinkIcon");return d(),u("div",null,[fa,s(t,{avatar:"../../assets/emoji/blzt.png",avatarWidth:40},{default:e(()=>[n(" 我想实现一个比较通用的血条材质类似LOL/守望/永劫那种。 ")]),_:1}),_a,s(t,{avatar:" ../../assets/emoji/new1.png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 别急着动手，先思考一下我们要实现哪些功能以及机制设定。 ")]),_:1}),s(t,{avatar:"../../assets/emoji/blzt.png",avatarWidth:40},{default:e(()=>[n(" 一个正常的血条修改看到需要有个加减值反馈，比如下面这样 ")]),_:1}),ba,ha,s(t,{avatar:" ../../assets/emoji/new1.png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 这个是最简单基础的功能，但视觉上我们无法确定这个血量是从什么地方开始修改的。 ")]),_:1}),s(t,{avatar:"../../assets/emoji/blzt.png",avatarWidth:40},{default:e(()=>[n(" 我可以给他加个过度状态。 ")]),_:1}),va,ka,s(t,{avatar:" ../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 如果没有显示血量值阁下如何应对。 ")]),_:1}),s(t,{avatar:"../../assets/emoji/new11.png",avatarWidth:55},{default:e(()=>[n(" 简单加个刻度就行了！比如一个格子10血。 ")]),_:1}),xa,ja,s(t,{avatar:" ../../assets/emoji/new2.png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" Good！如果我通过Buff或者一些游戏机制永久修改你的上下限，阁下如何应对？ ")]),_:1}),s(t,{avatar:"../../assets/emoji/new11.png",avatarWidth:55},{default:e(()=>[n(" 这还不简单，直接加上或者减少血条上下限不就行了！ ")]),_:1}),Wa,s(t,{avatar:"../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 小伙子想的挺美，你设计的UI可是固定尺寸的，总不能一修改就改UI尺寸吧！ ")]),_:1}),ya,s(t,{avatar:"../../assets/emoji/kclr.png",avatarWidth:40},{default:e(()=>[n(" 你这么说好像确实没法这么玩！ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 一般设定的一个格子多少血量可以认为是常量。意味着，我们需要动态修改我的显示格子数量来自适应我们的修改上下限。 ")]),_:1}),Ra,s(t,{avatar:"../../assets/emoji/bqb01.png",avatarWidth:40},{default:e(()=>[n(" 还有一种情况，如果是临时效果比如类似免死技能呢？ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 你说的是类似OW巴蒂那种免死机制是吧，你可以模仿他做一个额外的UI。 ")]),_:1}),qa,s(t,{avatar:"../../assets/emoji/bqb01.png",avatarWidth:40},{default:e(()=>[n(" 也就是说需要实现这样？ ")]),_:1}),za,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 你这个设计咋一看没毛病，但我先卖个关子，先给出我的设计构思。 ")]),_:1}),La,Da,s(t,{avatar:" ../../assets/emoji/bqb01.png",avatarWidth:40},{default:e(()=>[n(" 这里面我感觉最容易实现的是格子部分，用一张线条贴图进行平铺就行了！ ")]),_:1}),Ca,s(t,{avatar:" ../../assets/emoji/new1.png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 这个想法乍一看没什么毛病。 ")]),_:1}),wa,s(t,{avatar:" ../../assets/emoji/bqb01.png",avatarWidth:40},{default:e(()=>[n(" 等等！为什么你的材质节点和我的不一样？ ")]),_:1}),Va,s(t,{avatar:" ../../assets/emoji/new1.png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 这个简单，你把材质域改成用户界面就行了。 ")]),_:1}),Ua,s(t,{avatar:" ../../assets/emoji/dsyj.png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 回到正题。你这种方案平铺次数增加以后线条会看不清。 ")]),_:1}),Sa,s(t,{avatar:" ../../assets/emoji/dsyj.png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 设计的血条UI一般是固定尺寸的，不可能随着血量/护甲增加更改视觉尺寸。 ")]),_:1}),s(t,{avatar:" ../../assets/emoji/new7.png",avatarWidth:40},{default:e(()=>[Ba]),_:1}),Oa,s(t,{avatar:" ../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 说说你的思路 ")]),_:1}),s(t,{avatar:" ../../assets/emoji/new7.png",avatarWidth:40},{default:e(()=>[n(" 既然用贴图重复后会出现贴图压缩问题，我用手动画线不就行了！ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 看来你并不理解贴图平铺的本质，这种画线方案依然会出现压缩问题。 ")]),_:1}),Ea,s(t,{avatar:" ../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 而且这个节点的实现花里胡哨的。 ")]),_:1}),Na,s(t,{avatar:" ../../assets/emoji/new7.png",avatarWidth:40},{default:e(()=>[n(" 那你有什么方案可以实现吗？ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 别急，先了解一些基本概念。 ")]),_:1}),Ia,Pa,s(t,{avatar:" ../../assets/emoji/new7.png",avatarWidth:40},{default:e(()=>[n(" 打住打住，为什么突然介绍起这个节点？ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 别急，这个节点的目的是让你理解一下UE材质的坐标系。 ")]),_:1}),s(t,{avatar:" ../../assets/emoji/new7.png",avatarWidth:40},{default:e(()=>[n(" 为什么要理解UV坐标，这和我们画血条格子有什么关系？ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 既然咱们要在屏幕上绘制线条，必然要确定绘制在哪，以及怎么绘制。 ")]),_:1}),Ga,Ta,s(t,{avatar:" ../../assets/emoji/new7.png",avatarWidth:40},{default:e(()=>[n(" 可是，为什么这个坐标系是0-1内呢？ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 这种规范化的纹理坐标使得在不同大小的纹理上使用相同的坐标值成为可能，因为无论纹理的实际尺寸如何，纹理坐标都是相对于纹理的尺寸进行规范化的。 ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (6).png",avatarWidth:40},{default:e(()=>[n(" 搜得寺内！ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/new2.png",avatarWidth:50,alignLeft:""},{default:e(()=>[n(" 别打岔，我们继续介绍。在屏幕上画图并不像我们平时用PS画图那样简单，我们需要通过坐标和颜色配合画图。 ")]),_:1}),Aa,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 如果在材质中没有显式地指定UV坐标（或者说你没有应用任何处理UV的节点），系统会默认使用整个UV范围。 ")]),_:1}),Ha,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 如果在材质中没有显式地指定UV坐标（或者说你没有应用任何处理UV的节点），系统会默认使用整个UV范围。 ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb01.png",avatarWidth:40},{default:e(()=>[n(" 然后呢，现在知道坐标以及颜色表示方法了，我怎么指定坐标绘制颜色呢？ ")]),_:1}),Ma,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[Fa]),_:1}),Xa,Ya,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[Ja]),_:1}),Ka,Qa,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[Za]),_:1}),$a,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[an]),_:1}),nn,s(t,{avatar:" ../../assets/emoji/bqb (6).png",avatarWidth:40},{default:e(()=>[n(" 搜嘎！也就是说我们只需要控制红色部分占比就能实现画线效果！ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (5).png",avatarWidth:40},{default:e(()=>[n(" 可是似乎Frac平铺后仍然无法解决线条占比问题啊！ ")]),_:1}),sn,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 平铺（tiling）行为时，使用Frac节点来处理纹理坐标，每一个循环单元坐标依然是左上角(0.,0.)右下角(1.0,1.0)。 但显示时依然会被映射到原来的0-1范围中。 ")]),_:1}),tn,en,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 这里的B可以理解成单个循环的百分比，比如0.5对应的是50%，但重复2次后视觉上已经不再是50%了而是25%。 所以需要单个循环需要补偿25% ")]),_:1}),on,ln,s(t,{avatar:" ../../assets/emoji/bqb (6).png",avatarWidth:40},{default:e(()=>[n(" 问题来了！这里我们无法获取物理尺寸啊！组件不同显示的占比相同也没用啊！ ")]),_:1}),rn,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 设计UI时候有一个设计尺寸，虽然不同分辨率下显示的物理尺寸不同，但他的显示比例是固定的。比如我们的设计尺寸是300， 然后设定的间隔是3像素，意味着对应的占比为3/300= 1/100,即百分之1。 ")]),_:1}),cn,pn,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 如果第一次就设定理想占比为0.01，意味着N次平铺重映射后，单个间隔占比都会0.01/N,因此我们需要补偿回0.01。 即单个循环内0.01xN. ")]),_:1}),dn,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 这种补偿机制也有缺点，理想间隔x平铺次数 会出现大于1的情况。因此我们需要钳制这个范围。 ")]),_:1}),un,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 同时还应该考虑设定血量等于一个格子血量的情况，比如设定100，一个格子血量也是100，此时就不应该绘制间隔。 这么一来节点就有点复杂了，我们可以用Custom节点，通过HLSL实现。 ")]),_:1}),gn,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 自此我们已经实现了血量增加动态绘制格子的效果。 ")]),_:1}),s(o,{src:"../../assets/unrealgif/hpbar.gif"}),s(t,{avatar:" ../../assets/emoji/bqb (6).png",avatarWidth:40},{default:e(()=>[n(" 那么血条的几个状态的绘制该这么做呢？ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 你觉得可以怎么做? ")]),_:1}),mn,s(t,{avatar:" ../../assets/emoji/bqb (4).png",avatarWidth:40},{default:e(()=>[n(" 根据之前的知识，我认为用if配合remap就能解决 ")]),_:1}),fn,_n,s(t,{avatar:" ../../assets/emoji/bqb (4).png",avatarWidth:40},{default:e(()=>[n(" 而且可以利用正负实现加减血的效果，同时不会溢出！简直完美！ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 先别急着高兴，你这个血条有个大问题，你现在试着修改你的最大血量你看看发生了什么！ ")]),_:1}),s(o,{src:"../../assets/unrealgif/hpimpove.gif"}),s(t,{avatar:" ../../assets/emoji/bqb (4).png",avatarWidth:40},{default:e(()=>[n(" 修改血量上限时原本的血量也被增加了！ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 是的，而且目前来说我们并没有讨论CurrentValue，而是血量显示的正常状态NormalValue。 ")]),_:1}),bn,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 修改一下思路后的效果： ")]),_:1}),s(o,{src:"../../assets/unrealgif/hpimpove2.gif"}),hn,s(t,{avatar:" ../../assets/emoji/new3.png",avatarWidth:50},{default:e(()=>[n(" 妙啊！当前英雄总血量 = InitValue + limitValue被完美的映射到0-1中！ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 是的，这样的好处是limitValue修改也不会影响当前血量值。 ")]),_:1}),vn,s(t,{avatar:" ../../assets/emoji/bqb (4).png",avatarWidth:40},{default:e(()=>[n(" 我看你的A=B连到了红色，有什么讲究吗？ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 表面上看是一个临界值，还是有点学问的，首先，NormalValue代表真实血量值，A=B意味着真实血量=设定血量，所以应该连到红色。 ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 目前我们已经实现了下图的① ")]),_:1}),kn,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 你觉得Current状态怎么加入? ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (4).png",avatarWidth:40},{default:e(()=>[n(" 我觉得挺容易的，下面这样就能实现。 ")]),_:1}),xn,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 你这么连NormalValue状态修改会连带CurrentValue修改。 ")]),_:1}),s(o,{src:"../../assets/unrealgif/hpimpove3.gif"}),s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 我们需要明确Current状态的由来，即时间对血条状态的影响。 ")]),_:1}),jn,s(t,{avatar:" ../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 按照我们的设计思路顺序是应该是先影响NormalValue，然后N秒内播放CurrentValue动画。 ")]),_:1}),Wn,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 而且似乎你对IF节点有高度依赖！打开一下思路，想想有没有办法不通过IF实现。 ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (4).png",avatarWidth:40},{default:e(()=>[n(" 还真没什么思路！ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 还记得之前的TexCoord节点吗，我们知道它是由两个方向的衰减贴图合成的，那你知道这个衰减贴图是线性的还是非线性的？ ")]),_:1}),yn,Rn,s(t,{avatar:" ../../assets/emoji/bqb (4).png",avatarWidth:40},{default:e(()=>[n(" 线性的！规范的LineGradient节点就是这么来的！ ")]),_:1}),qn,s(t,{avatar:" ../../assets/emoji/bqb (4).png",avatarWidth:40},{default:e(()=>[n(" 可是我有个疑惑，线性的为什么看着颜色并不是从黑到白均匀过度？ ")]),_:1}),zn,s(t,{avatar:" ../../assets/emoji/bqb (4).png",avatarWidth:40},{default:e(()=>[n(" 难道不应该像上面这个条一样？ ")]),_:1}),Ln,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 这个问题你还是看看大佬的视频吧！ ")]),_:1}),Dn,s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 这里我们先看结论，下图可以看到0.25的位置对应的正好是颜色的rgb(0.25,0.25,0.25) ")]),_:1}),Cn,s(t,{avatar:" ../../assets/emoji/bqb01.png",avatarWidth:40},{default:e(()=>[n(" 这和我们制作血条有什么关系吗？ ")]),_:1}),s(t,{avatar:" ../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 讲解方法前我们先巩固一下我们的学习知识，我们的颜色从黑到白是从0-1过度的，0是黑色，1是白色。 ")]),_:1}),s(t,{avatar:" ../../assets/emoji/new1.png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 接着我们认识一个新节点叫做Ceil，后面要考！ ")]),_:1}),wn,s(t,{avatar:" ../../assets/emoji/new1.png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 我们来做一个简单的数学问题！ ")]),_:1}),Vn,s(t,{avatar:" ../../assets/emoji/bqb (6).png",avatarWidth:40},{default:e(()=>[n(" 卧槽！ ")]),_:1}),Un,s(t,{avatar:" ../../assets/emoji/new1.png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 你没有看错，格子问题本质是动态计算间隔，现在间隔的绘制方法有了新的方案。 ")]),_:1}),Sn,s(t,{avatar:" ../../assets/emoji/new1.png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 接着，咱们尝试用新方法描述一下血条状态。 ")]),_:1}),Bn,On,s(t,{avatar:" ../../assets/emoji/new1.png",avatarWidth:40,alignLeft:""},{default:e(()=>[n(" 配合Lerp还能做出更加炫酷的效果 ")]),_:1}),En,s(o,{src:"../../assets/unrealgif/hpimpove4.gif"}),Nn,a("p",null,[a("a",In,[n("1.微软官网"),s(r)])]),a("p",null,[a("a",Pn,[n("2.【UE4】HLSL语言基础"),s(r)])])])}const Mn=p(ma,[["render",Gn],["__file","1-HPBar.html.vue"]]);export{Mn as default};
