"use strict";(self.webpackChunkrenderdoc=self.webpackChunkrenderdoc||[]).push([[2001],{9125:(n,a,s)=>{s.r(a),s.d(a,{comp:()=>c,data:()=>l});var p=s(20641);const t=(0,p.Fv)('<ol><li><p><strong>访问私有成员：</strong> 如果有一些与类密切相关的非成员函数需要访问类的私有成员， 但这些函数不适合成为类的成员函数，可以将它们声明为友元函数，以便访问类的私有部分。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>\n<span class="token keyword">private</span><span class="token operator">:</span>\n    <span class="token keyword">int</span> privateData<span class="token punctuation">;</span>\n\n<span class="token keyword">public</span><span class="token operator">:</span>\n    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">privateData</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n    <span class="token comment">// 友元函数的声明</span>\n    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">displayPrivateData</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 友元函数的定义</span>\n<span class="token keyword">void</span> <span class="token function">displayPrivateData</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Private Data: &quot;</span> <span class="token operator">&lt;&lt;</span> obj<span class="token punctuation">.</span>privateData <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>提高效率：</strong> 有时，为了提高效率，需要使用非成员函数来执行某些操作，而这些操作需要访问类的私有成员。通过将这些函数声明为友元，可以避免将所有操作都包装成成员函数。</p></li><li><p><strong>重载运算符：</strong> 重载某些运算符时，可能需要直接访问类的私有成员。友元函数允许非成员函数重载类的运算符并访问类的私有部分。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">{</span>\n<span class="token keyword">private</span><span class="token operator">:</span>\n    <span class="token keyword">double</span> real<span class="token punctuation">;</span>\n    <span class="token keyword">double</span> imag<span class="token punctuation">;</span>\n\n<span class="token keyword">public</span><span class="token operator">:</span>\n    <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> r<span class="token punctuation">,</span> <span class="token keyword">double</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">real</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">imag</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n    <span class="token comment">// 友元函数的声明</span>\n    <span class="token keyword">friend</span> Complex <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 友元函数的定义</span>\nComplex <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">Complex</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>real <span class="token operator">+</span> b<span class="token punctuation">.</span>real<span class="token punctuation">,</span> a<span class="token punctuation">.</span>imag <span class="token operator">+</span> b<span class="token punctuation">.</span>imag<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol>',1),e=(0,p.Lk)("br",null,null,-1),o={},c=(0,s(66262).A)(o,[["render",function(n,a){const s=(0,p.g2)("chatmessage");return(0,p.uX)(),(0,p.CE)("div",null,[(0,p.bF)(s,{avatar:"../../../assets/emoji/hx.png",avatarWidth:40},{default:(0,p.k6)((()=>[(0,p.eW)(" 之前咱介绍了class中的三个访问控制修饰符`public`、`protected` 和 `private` 其中`private`控制的成员属性和函数是不是只能通过本身访问。 ")])),_:1}),(0,p.bF)(s,{avatar:"../../../assets/emoji/dsyj.png",avatarWidth:40,alignLeft:""},{default:(0,p.k6)((()=>[(0,p.eW)(" 并不绝对，你可以用友元函数开放权限。 ")])),_:1}),(0,p.bF)(s,{avatar:"../../../assets/emoji/bqb01.png",avatarWidth:40},{default:(0,p.k6)((()=>[(0,p.eW)(" 就像开放权限给我的好朋友查看的意思？ ")])),_:1}),(0,p.bF)(s,{avatar:"../../../assets/emoji/dsyj.png",avatarWidth:40,alignLeft:""},{default:(0,p.k6)((()=>[(0,p.eW)(" 没错，可以这样理解。友元函数的存在就像是你的类把某个函数声明为“好朋友”，允许它访问类的私有成员。 ")])),_:1}),(0,p.bF)(s,{avatar:"../../../assets/emoji/new3.png",avatarWidth:50},{default:(0,p.k6)((()=>[(0,p.eW)(" 那具体该怎么用呢？ ")])),_:1}),(0,p.bF)(s,{avatar:"../../../assets/emoji/new1.png",avatarWidth:40,alignLeft:""},{default:(0,p.k6)((()=>[(0,p.eW)(" 友元函数的声明通常放在类的定义中，并使用 friend 关键字。有几个特性： ")])),_:1}),t,(0,p.bF)(s,{avatar:"../../../assets/emoji/new11.png",avatarWidth:55},{default:(0,p.k6)((()=>[(0,p.eW)(" 可是如果滥用，岂不是这个`private`就形同虚设，也就破坏了类的封装性。 ")])),_:1}),(0,p.bF)(s,{avatar:"../../../assets/emoji/bqb (1).png",avatarWidth:40,alignLeft:""},{default:(0,p.k6)((()=>[(0,p.eW)(" 是的，过度使用友元函数还可能可能导致代码难以维护和理解。"),e,(0,p.eW)(" 一般来说，尽量在类内部提供成员函数来实现需要访问私有成员的操作，而只在确实需要时才使用友元函数。 ")])),_:1})])}]]),l=JSON.parse('{"path":"/language/cpp/keywords_%E5%85%B3%E9%94%AE%E5%AD%97_/6-Keywords%20friend.html","title":"c++6.friend","lang":"zh-CN","frontmatter":{"title":"c++6.friend","order":6,"category":["c++"],"description":"访问私有成员： 如果有一些与类密切相关的非成员函数需要访问类的私有成员， 但这些函数不适合成为类的成员函数，可以将它们声明为友元函数，以便访问类的私有部分。 提高效率： 有时，为了提高效率，需要使用非成员函数来执行某些操作，而这些操作需要访问类的私有成员。通过将这些函数声明为友元，可以避免将所有操作都包装成成员函数。 重载运算符： 重载某些运算符时，可...","head":[["meta",{"property":"og:url","content":"https://rendertool.github.io/RenderDoc/language/cpp/keywords_%E5%85%B3%E9%94%AE%E5%AD%97_/6-Keywords%20friend.html"}],["meta",{"property":"og:site_name","content":"RenderDoc"}],["meta",{"property":"og:title","content":"c++6.friend"}],["meta",{"property":"og:description","content":"访问私有成员： 如果有一些与类密切相关的非成员函数需要访问类的私有成员， 但这些函数不适合成为类的成员函数，可以将它们声明为友元函数，以便访问类的私有部分。 提高效率： 有时，为了提高效率，需要使用非成员函数来执行某些操作，而这些操作需要访问类的私有成员。通过将这些函数声明为友元，可以避免将所有操作都包装成成员函数。 重载运算符： 重载某些运算符时，可..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-02T22:07:13.000Z"}],["meta",{"property":"article:author","content":"Mr.Si"}],["meta",{"property":"article:modified_time","content":"2024-01-02T22:07:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"c++6.friend\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-01-02T22:07:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Si\\",\\"url\\":\\"https://rendertool.github.io/RenderDoc/\\"}]}"]]},"headers":[],"git":{"createdTime":1703074087000,"updatedTime":1704233233000,"contributors":[{"name":"admin","email":"750831855@qq.com","commits":1},{"name":"sigaohe","email":"750831855@qq.com","commits":1}]},"readingTime":{"minutes":2.06,"words":619},"filePathRelative":"language/cpp/keywords[关键字]/6-Keywords friend.md","localizedDate":"2023年12月20日","excerpt":"\\n\\n\\n\\n\\n\\n<ol>\\n<li>\\n<p><strong>访问私有成员：</strong> 如果有一些与类密切相关的非成员函数需要访问类的私有成员，\\n但这些函数不适合成为类的成员函数，可以将它们声明为友元函数，以便访问类的私有部分。</p>\\n<div class=\\"language-cpp\\" data-ext=\\"cpp\\" data-title=\\"cpp\\"><pre class=\\"language-cpp\\"><code><span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">MyClass</span> <span class=\\"token punctuation\\">{</span>\\n<span class=\\"token keyword\\">private</span><span class=\\"token operator\\">:</span>\\n    <span class=\\"token keyword\\">int</span> privateData<span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token keyword\\">public</span><span class=\\"token operator\\">:</span>\\n    <span class=\\"token function\\">MyClass</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">:</span> <span class=\\"token function\\">privateData</span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">0</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n\\n    <span class=\\"token comment\\">// 友元函数的声明</span>\\n    <span class=\\"token keyword\\">friend</span> <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">displayPrivateData</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> MyClass<span class=\\"token operator\\">&amp;</span> obj<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token comment\\">// 友元函数的定义</span>\\n<span class=\\"token keyword\\">void</span> <span class=\\"token function\\">displayPrivateData</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> MyClass<span class=\\"token operator\\">&amp;</span> obj<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n    std<span class=\\"token double-colon punctuation\\">::</span>cout <span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"Private Data: \\"</span> <span class=\\"token operator\\">&lt;&lt;</span> obj<span class=\\"token punctuation\\">.</span>privateData <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token double-colon punctuation\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div></li>\\n<li>\\n<p><strong>提高效率：</strong> 有时，为了提高效率，需要使用非成员函数来执行某些操作，而这些操作需要访问类的私有成员。通过将这些函数声明为友元，可以避免将所有操作都包装成成员函数。</p>\\n</li>\\n<li>\\n<p><strong>重载运算符：</strong> 重载某些运算符时，可能需要直接访问类的私有成员。友元函数允许非成员函数重载类的运算符并访问类的私有部分。</p>\\n<div class=\\"language-cpp\\" data-ext=\\"cpp\\" data-title=\\"cpp\\"><pre class=\\"language-cpp\\"><code><span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">Complex</span> <span class=\\"token punctuation\\">{</span>\\n<span class=\\"token keyword\\">private</span><span class=\\"token operator\\">:</span>\\n    <span class=\\"token keyword\\">double</span> real<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">double</span> imag<span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token keyword\\">public</span><span class=\\"token operator\\">:</span>\\n    <span class=\\"token function\\">Complex</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">double</span> r<span class=\\"token punctuation\\">,</span> <span class=\\"token keyword\\">double</span> i<span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">:</span> <span class=\\"token function\\">real</span><span class=\\"token punctuation\\">(</span>r<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">,</span> <span class=\\"token function\\">imag</span><span class=\\"token punctuation\\">(</span>i<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n\\n    <span class=\\"token comment\\">// 友元函数的声明</span>\\n    <span class=\\"token keyword\\">friend</span> Complex <span class=\\"token keyword\\">operator</span><span class=\\"token operator\\">+</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> Complex<span class=\\"token operator\\">&amp;</span> a<span class=\\"token punctuation\\">,</span> <span class=\\"token keyword\\">const</span> Complex<span class=\\"token operator\\">&amp;</span> b<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token comment\\">// 友元函数的定义</span>\\nComplex <span class=\\"token keyword\\">operator</span><span class=\\"token operator\\">+</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> Complex<span class=\\"token operator\\">&amp;</span> a<span class=\\"token punctuation\\">,</span> <span class=\\"token keyword\\">const</span> Complex<span class=\\"token operator\\">&amp;</span> b<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token keyword\\">return</span> <span class=\\"token function\\">Complex</span><span class=\\"token punctuation\\">(</span>a<span class=\\"token punctuation\\">.</span>real <span class=\\"token operator\\">+</span> b<span class=\\"token punctuation\\">.</span>real<span class=\\"token punctuation\\">,</span> a<span class=\\"token punctuation\\">.</span>imag <span class=\\"token operator\\">+</span> b<span class=\\"token punctuation\\">.</span>imag<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div></li>\\n</ol>","autoDesc":true}')}}]);