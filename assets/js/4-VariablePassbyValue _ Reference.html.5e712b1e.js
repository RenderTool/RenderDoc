"use strict";(self.webpackChunkrenderdoc=self.webpackChunkrenderdoc||[]).push([[9454],{62923:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>w,data:()=>x});var e=a(20641);const t=a.p+"assets/img/referenceorvalue.884e2683.png",p=a.p+"assets/img/valueblueprint.9af4fd8b.png",i=a.p+"assets/img/referenceblueprint.3779ff22.png",o=a.p+"assets/img/runreference.d07a1a9c.gif",l=a.p+"assets/img/referenceerrorcpp.65e8353f.png",c=a.p+"assets/img/runvaluegif.89860999.gif",r=a.p+"assets/img/runreferencegif.00082e2d.gif",u=(0,e.Fv)('<h3 id="值传递" tabindex="-1"><a class="header-anchor" href="#值传递"><span>值传递</span></a></h3><ol><li><p><strong>传递方式：</strong> 通过将实际参数的值复制给形式参数，函数得到的是实际数据的副本。</p></li><li><p><strong>对实参的影响：</strong> 在函数内对形式参数的修改不会影响实际参数的值。</p></li><li><p><strong>内存开销：</strong> 由于复制了实际参数的值，可能会产生额外的内存开销，尤其是对于大型对象或数据结构。</p></li><li><p><strong>使用时机：</strong> 适用于简单的数据类型或对象，或者当函数不需要修改实际参数的值时。</p></li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>\n<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>\n\n<span class="token comment">//值传递</span>\n<span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\tcout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>\n    x<span class="token operator">++</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n    <span class="token function">increment</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结果打印5</span>\n    <span class="token function">increment</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结果打印5</span>\n    <span class="token function">increment</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结果打印5</span>\n    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',3),d=(0,e.Fv)('<h3 id="引用传递" tabindex="-1"><a class="header-anchor" href="#引用传递"><span>引用传递</span></a></h3><ol><li><p><strong>传递方式：</strong> 通过将实际参数的地址传递给形式参数，函数得到的是实际数据的引用。</p></li><li><p><strong>对实参的影响：</strong> 在函数内对形式参数的修改会影响实际参数的值。</p></li><li><p><strong>内存开销：</strong> 不会产生额外的内存开销，因为没有进行值的复制。</p></li><li><p><strong>使用时机：</strong> 适用于需要修改实际参数的值或希望避免复制大型对象的情况。</p></li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>\n<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>\n\n<span class="token comment">//引用传递</span>\n<span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\tcout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>\n    x<span class="token operator">++</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n    <span class="token function">increment</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结果打印5</span>\n    <span class="token function">increment</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结果打印6</span>\n    <span class="token function">increment</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结果打印7</span>\n    cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//打印8因为实际参数被改变了</span>\n    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',3),k=(0,e.Fv)('<h3 id="const引用传递" tabindex="-1"><a class="header-anchor" href="#const引用传递"><span>Const引用传递</span></a></h3><ol><li><p><strong>传递方式：</strong> 通过将实际参数的引用传递给形式参数，函数得到的是实际数据的引用。使用<code>const</code>关键字表示在函数内不能修改实际参数的值。</p></li><li><p><strong>对实参的影响：</strong> 在函数内不允许对形式参数的值进行修改，以保持实际参数的不变性。</p></li><li><p><strong>内存开销：</strong> 传递的是引用而不是值的副本，因此相比于值传递，内存开销较小。但在函数内部无法修改实际参数的值。</p></li><li><p><strong>使用时机：</strong> 适用于需要访问实际参数的值但不需要修改的情况，同时希望减小内存开销。</p></li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>\n<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>\n\n<span class="token comment">// const引用传递</span>\n<span class="token keyword">int</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 返回x递增后的值</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n    num <span class="token operator">=</span> <span class="token function">increment</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将新值赋给num</span>\n    cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 打印递增后的值</span>\n    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',3),m=(0,e.Fv)('<p>在上述示例中，const引用传递避免了对实际参数的复制，同时限制了函数内部对实际参数的修改。</p><h3 id="指针传递" tabindex="-1"><a class="header-anchor" href="#指针传递"><span>指针传递</span></a></h3><ol><li><p><strong>传递方式：</strong> 通过将实际参数的地址传递给形式参数，函数得到的是实际数据的地址，可以通过该地址直接访问和修改实际参数的值。</p></li><li><p><strong>对实参的影响：</strong> 在函数内对形式参数所指向的地址的内容进行修改会影响实际参数的值。</p></li><li><p><strong>内存开销：</strong> 传递的是地址而不是值的副本，因此通常比值传递更节省内存，尤其对于大型对象或数据结构。</p></li><li><p><strong>使用时机：</strong> 适用于需要在函数内修改实际参数的值，或者当希望减小内存开销的情况。</p></li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>\n<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>\n\n<span class="token comment">//指针传递</span>\n<span class="token keyword">void</span> <span class="token function">incrementByPointer</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>\n  <span class="token punctuation">{</span>\n      cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 输出实际参数的值</span>\n      <span class="token punctuation">(</span><span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 通过指针修改实际参数的值</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n    <span class="token function">incrementByPointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 传递实际参数的地址</span>\n    cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 输出修改后的实际参数的值，结果为6</span>\n    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="深浅拷贝" tabindex="-1"><a class="header-anchor" href="#深浅拷贝"><span>深浅拷贝</span></a></h2>',5),v=(0,e.Fv)('<ol><li><strong>值传递（Pass by Value）：</strong></li></ol><ul><li>在值传递中，函数参数是原始值的拷贝，即创建了一个局部变量并将原始值的内容复制到局部变量中。</li><li>这确实涉及到拷贝原始值，但这并不一定是深拷贝。对于基本数据类型（如整数、浮点数），这是深拷贝，因为整个值被复制。</li><li>对于复杂对象（如数组、结构体、类），可能是浅拷贝，因为只是复制对象的内容，而不是对象本身的复制。</li></ul><ol start="2"><li><strong>引用传递（Pass by Reference）：</strong></li></ol><ul><li>在引用传递中，函数参数是原始值的引用，即创建了一个别名或引用，直接指向原始值的内存地址。</li><li>引用传递通常被认为是一种浅拷贝，因为它不涉及对值的复制，而是共享同一块内存。修改引用传递的参数会影响原始值。</li></ul>',4),g=(0,e.Lk)("span",{style:{color:"#c0392b","font-size":"1.2rem"}},"深浅拷贝",-1),b=(0,e.Lk)("h2",{id:"正片",tabindex:"-1"},[(0,e.Lk)("a",{class:"header-anchor",href:"#正片"},[(0,e.Lk)("span",null,"正片")])],-1),f=(0,e.Fv)('<h3 id="_1-创建" tabindex="-1"><a class="header-anchor" href="#_1-创建"><span>1.创建</span></a></h3><blockquote><p>对应的蓝图节点</p></blockquote><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+p+'" alt="默认值传递" tabindex="0" loading="lazy"><figcaption>默认值传递</figcaption></figure><figure><img src="'+i+'" alt="值引用" tabindex="0" loading="lazy"><figcaption>值引用</figcaption></figure><h3 id="_2-运行" tabindex="-1"><a class="header-anchor" href="#_2-运行"><span>2.运行</span></a></h3>',6),h=(0,e.Fv)('<figure><img src="'+o+'" alt="默认参数是1" tabindex="0" loading="lazy"><figcaption>默认参数是1</figcaption></figure><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-debug" tabindex="-1"><a class="header-anchor" href="#_3-debug"><span>3.Debug</span></a></h3><figure><img src="'+c+'" alt="值传递" tabindex="0" loading="lazy"><figcaption>值传递</figcaption></figure><figure><img src="'+r+'" alt="值引用" tabindex="0" loading="lazy"><figcaption>值引用</figcaption></figure>',5),y={},w=(0,a(66262).A)(y,[["render",function(n,s){const a=(0,e.g2)("chatmessage"),t=(0,e.g2)("gifwithbutton");return(0,e.uX)(),(0,e.CE)("div",null,[(0,e.bF)(a,{avatar:"../../../assets/emoji/blzt.png",avatarWidth:40},{default:(0,e.k6)((()=>[(0,e.eW)(" 值传递（Pass by Value）和引用传递（Pass by Reference）以及指针传递（Pass by Pointer） ")])),_:1}),u,(0,e.bF)(t,{src:"../../../assets/unrealgif/vyy.gif"}),d,(0,e.bF)(t,{src:"../../../assets/unrealgif/vyy2.gif"}),k,(0,e.bF)(t,{src:"../../../assets/unrealgif/vyy3.gif"}),m,(0,e.bF)(a,{avatar:"../../../assets/emoji/bqb (4).png",avatarWidth:40},{default:(0,e.k6)((()=>[(0,e.eW)(" 按你这么说也就是说值传递是深拷贝？引用传递是浅拷贝喽？ ")])),_:1}),(0,e.bF)(a,{avatar:"../../../assets/emoji/bqb (6).png",avatarWidth:40,alignLeft:""},{default:(0,e.k6)((()=>[(0,e.eW)(" 不完全正确！，我们还是得根据实际情况判断是什么拷贝。 ")])),_:1}),v,(0,e.bF)(a,{avatar:"../../../assets/emoji/hx.png",avatarWidth:40},{default:(0,e.k6)((()=>[(0,e.eW)(" 我不理解！我只是经常听他们提到"),g,(0,e.eW)("。 ")])),_:1}),(0,e.bF)(a,{avatar:"../../../assets/emoji/bqb (6).png",avatarWidth:40,alignLeft:""},{default:(0,e.k6)((()=>[(0,e.eW)(" 后续文章再做讨论吧。 ")])),_:1}),b,(0,e.bF)(a,{avatar:"../../../assets/emoji/bqb (6).png",avatarWidth:40,alignLeft:""},{default:(0,e.k6)((()=>[(0,e.eW)(" 贴心Baba在UE中用蓝图节点模拟了一下值传递和值引用 ")])),_:1}),f,(0,e.bF)(a,{avatar:"../../../assets/emoji/new1.png",avatarWidth:40,alignLeft:""},{default:(0,e.k6)((()=>[(0,e.eW)(" 如果用+=则需要重新对原始数据赋值操作，而++对变量进行自增的操作。至于用++i还是i++在这里没什么区别，我们后续文章也会讨论。 ")])),_:1}),h])}]]),x=JSON.parse('{"path":"/language/cpp/BaseGuide_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5_/4-VariablePassbyValue%20_%20Reference.html","title":"c++5.参数传递","lang":"zh-CN","frontmatter":{"title":"c++5.参数传递","order":5,"category":["c++"],"description":"值传递 传递方式： 通过将实际参数的值复制给形式参数，函数得到的是实际数据的副本。 对实参的影响： 在函数内对形式参数的修改不会影响实际参数的值。 内存开销： 由于复制了实际参数的值，可能会产生额外的内存开销，尤其是对于大型对象或数据结构。 使用时机： 适用于简单的数据类型或对象，或者当函数不需要修改实际参数的值时。","head":[["meta",{"property":"og:url","content":"https://rendertool.github.io/RenderDoc/RenderDoc/language/cpp/BaseGuide_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5_/4-VariablePassbyValue%20_%20Reference.html"}],["meta",{"property":"og:site_name","content":"RenderDoc"}],["meta",{"property":"og:title","content":"c++5.参数传递"}],["meta",{"property":"og:description","content":"值传递 传递方式： 通过将实际参数的值复制给形式参数，函数得到的是实际数据的副本。 对实参的影响： 在函数内对形式参数的修改不会影响实际参数的值。 内存开销： 由于复制了实际参数的值，可能会产生额外的内存开销，尤其是对于大型对象或数据结构。 使用时机： 适用于简单的数据类型或对象，或者当函数不需要修改实际参数的值时。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-02T22:07:13.000Z"}],["meta",{"property":"article:author","content":"Mr.Si"}],["meta",{"property":"article:modified_time","content":"2024-01-02T22:07:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"c++5.参数传递\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-01-02T22:07:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Si\\",\\"url\\":\\"https://rendertool.github.io/RenderDoc/\\"}]}"]]},"headers":[{"level":3,"title":"值传递","slug":"值传递","link":"#值传递","children":[]},{"level":3,"title":"引用传递","slug":"引用传递","link":"#引用传递","children":[]},{"level":3,"title":"Const引用传递","slug":"const引用传递","link":"#const引用传递","children":[]},{"level":3,"title":"指针传递","slug":"指针传递","link":"#指针传递","children":[]},{"level":2,"title":"深浅拷贝","slug":"深浅拷贝","link":"#深浅拷贝","children":[]},{"level":2,"title":"正片","slug":"正片","link":"#正片","children":[{"level":3,"title":"1.创建","slug":"_1-创建","link":"#_1-创建","children":[]},{"level":3,"title":"2.运行","slug":"_2-运行","link":"#_2-运行","children":[]},{"level":3,"title":"3.Debug","slug":"_3-debug","link":"#_3-debug","children":[]}]}],"git":{"createdTime":1700738130000,"updatedTime":1704233233000,"contributors":[{"name":"admin","email":"750831855@qq.com","commits":3},{"name":"sigaohe","email":"750831855@qq.com","commits":1}]},"readingTime":{"minutes":4.94,"words":1481},"filePathRelative":"language/cpp/BaseGuide[基础概念]/4-VariablePassbyValue & Reference.md","localizedDate":"2023年11月23日","excerpt":"\\n<h3>值传递</h3>\\n<ol>\\n<li>\\n<p><strong>传递方式：</strong> 通过将实际参数的值复制给形式参数，函数得到的是实际数据的副本。</p>\\n</li>\\n<li>\\n<p><strong>对实参的影响：</strong> 在函数内对形式参数的修改不会影响实际参数的值。</p>\\n</li>\\n<li>\\n<p><strong>内存开销：</strong> 由于复制了实际参数的值，可能会产生额外的内存开销，尤其是对于大型对象或数据结构。</p>\\n</li>\\n<li>\\n<p><strong>使用时机：</strong> 适用于简单的数据类型或对象，或者当函数不需要修改实际参数的值时。</p>\\n</li>\\n</ol>","autoDesc":true}')}}]);