"use strict";(self.webpackChunkrenderdoc=self.webpackChunkrenderdoc||[]).push([[750],{29013:(n,a,s)=>{s.r(a),s.d(a,{comp:()=>l,data:()=>i});var t=s(20641);const e=(0,t.Fv)('<h2 id="左值和右值" tabindex="-1"><a class="header-anchor" href="#左值和右值"><span>左值和右值</span></a></h2><h3 id="直觉判断" tabindex="-1"><a class="header-anchor" href="#直觉判断"><span>直觉判断</span></a></h3><p>C++98已经出现，字面理解表达式等号左边的值为左值，右边的右值。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//a是左值，1是右值</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是，如果按表达式等号左右标准的方式来判断会出现一些意外：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//按照之前的判断标准a是左值，1是右值</span>\n<span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//按照之前的判断标准b是左值，a是右值</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>行1<code>a</code>是左值，在行2<code>a</code>又变成了右值。</p><h3 id="标准判断" tabindex="-1"><a class="header-anchor" href="#标准判断"><span>标准判断</span></a></h3><p>与表达式的值分类和赋值有关。</p><ol><li><p><strong>左值 (Lvalue):</strong></p><ul><li><strong>定义：</strong> 左值是一个具有标识符的表达式，它表示一个对象或内存位置。左值可以出现在赋值语句的左边或右边。</li><li><strong>例子：</strong> 变量、数组元素、结构体成员等都是左值。</li><li><strong>性质：</strong> 左值具有持久性，它们在内存中有明确定义的位置。你可以取得左值的地址，对其进行引用，并且可以修改其值。</li></ul></li><li><p><strong>右值 (Rvalue):</strong></p><ul><li><strong>定义：</strong> 右值是一个不具有标识符的表达式，它通常是临时的、即时计算的值。右值出现在赋值语句的右边。</li><li><strong>例子：</strong> 字面常量、临时对象、表达式的计算结果等都是右值。</li><li><strong>性质：</strong> 右值通常是短暂的，它们在计算后可能就会失去意义。你不能对右值取地址，也不能修改其值。</li></ul></li></ol><h2 id="右值引用" tabindex="-1"><a class="header-anchor" href="#右值引用"><span>右值引用</span></a></h2><p>在C++11及以后的标准中，有一个引入的重要概念叫做<strong>右值引用</strong>（Rvalue Reference）， 通过 <code>&amp;&amp;</code> 表示。右值引用允许我们对右值进行引用，并通过移动语义实现高效的资源管理，例如在移动构造函数和移动赋值运算符中。</p>',12),p=(0,t.Fv)('<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>\n\nClass C <span class="token punctuation">{</span>\n    <span class="token keyword">public</span><span class="token operator">:</span>\n    <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n     <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;show&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nC <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    C c1<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> c1<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    C c2 <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//make()中默认构造，然后返回时出现一次复制构造，最后赋值给c2又发生复制构造。</span>\n    c<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',1),o=(0,t.Fv)('<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>\n\nClass C <span class="token punctuation">{</span>\n    <span class="token keyword">public</span><span class="token operator">:</span>\n    <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;show&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nC <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    C c1<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> c1<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\nC <span class="token operator">&amp;&amp;</span>c2 <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nc<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',1),c={},l=(0,s(66262).A)(c,[["render",function(n,a){const s=(0,t.g2)("chatmessage");return(0,t.uX)(),(0,t.CE)("div",null,[(0,t.bF)(s,{avatar:"../../../assets/emoji/dsyj.png",avatarWidth:40},{default:(0,t.k6)((()=>[(0,t.eW)(" 如何理解C++ 中的左值（Lvalue）和右值（Rvalue）？ ")])),_:1}),e,(0,t.bF)(s,{avatar:"../../../assets/emoji/dsyj.png",avatarWidth:40},{default:(0,t.k6)((()=>[(0,t.eW)(" 换成人话来讲，右值引用就是延长临时对象的生命周期，从而减少对象复制，提高程序性能。 ")])),_:1}),p,(0,t.bF)(s,{avatar:"../../../assets/emoji/dsyj.png",avatarWidth:40},{default:(0,t.k6)((()=>[(0,t.eW)(" 上面的代码中，如果没有进行编译器优化，会发生3次构造。make 中c1会被默认构造一次，return 中c1复制构造产生临时对象，接着赋值给c2时又会使用复制构造。 ")])),_:1}),(0,t.bF)(s,{avatar:"../../../assets/emoji/blzt.png",avatarWidth:40,alignLeft:""},{default:(0,t.k6)((()=>[(0,t.eW)(" SO!我们可以使用右值引用来延长这个临时对象的生命周期，减少复制。 ")])),_:1}),o])}]]),i=JSON.parse('{"path":"/language/cpp/new_%E6%96%B0%E7%89%B9%E6%80%A7_/2-Lvalues%20and%20Rvalues.html","title":"c++2.理解左右值和移动语义","lang":"zh-CN","frontmatter":{"title":"c++2.理解左右值和移动语义","order":2,"category":["c++"],"description":"左值和右值 直觉判断 C++98已经出现，字面理解表达式等号左边的值为左值，右边的右值。 但是，如果按表达式等号左右标准的方式来判断会出现一些意外： 行1a是左值，在行2a又变成了右值。 标准判断 与表达式的值分类和赋值有关。 左值 (Lvalue): 定义： 左值是一个具有标识符的表达式，它表示一个对象或内存位置。左值可以出现在赋值语句的左边或右边。...","head":[["meta",{"property":"og:url","content":"https://rendertool.github.io/RenderDoc/RenderDoc/language/cpp/new_%E6%96%B0%E7%89%B9%E6%80%A7_/2-Lvalues%20and%20Rvalues.html"}],["meta",{"property":"og:site_name","content":"RenderDoc"}],["meta",{"property":"og:title","content":"c++2.理解左右值和移动语义"}],["meta",{"property":"og:description","content":"左值和右值 直觉判断 C++98已经出现，字面理解表达式等号左边的值为左值，右边的右值。 但是，如果按表达式等号左右标准的方式来判断会出现一些意外： 行1a是左值，在行2a又变成了右值。 标准判断 与表达式的值分类和赋值有关。 左值 (Lvalue): 定义： 左值是一个具有标识符的表达式，它表示一个对象或内存位置。左值可以出现在赋值语句的左边或右边。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-03T22:22:12.000Z"}],["meta",{"property":"article:author","content":"Mr.Si"}],["meta",{"property":"article:modified_time","content":"2024-08-03T22:22:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"c++2.理解左右值和移动语义\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-03T22:22:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Si\\",\\"url\\":\\"https://rendertool.github.io/RenderDoc/\\"}]}"]]},"headers":[{"level":2,"title":"左值和右值","slug":"左值和右值","link":"#左值和右值","children":[{"level":3,"title":"直觉判断","slug":"直觉判断","link":"#直觉判断","children":[]},{"level":3,"title":"标准判断","slug":"标准判断","link":"#标准判断","children":[]}]},{"level":2,"title":"右值引用","slug":"右值引用","link":"#右值引用","children":[]}],"git":{"createdTime":1701724009000,"updatedTime":1722723732000,"contributors":[{"name":"sigaohe","email":"750831855@qq.com","commits":3},{"name":"admin","email":"750831855@qq.com","commits":1}]},"readingTime":{"minutes":2.46,"words":738},"filePathRelative":"language/cpp/new[新特性]/2-Lvalues and Rvalues.md","localizedDate":"2023年12月4日","excerpt":"\\n<h2>左值和右值</h2>\\n<h3>直觉判断</h3>\\n<p>C++98已经出现，字面理解表达式等号左边的值为左值，右边的右值。</p>\\n<div class=\\"language-cpp\\" data-ext=\\"cpp\\" data-title=\\"cpp\\"><pre class=\\"language-cpp\\"><code><span class=\\"token keyword\\">int</span> a <span class=\\"token operator\\">=</span> <span class=\\"token number\\">1</span><span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">//a是左值，1是右值</span>\\n</code></pre></div>","autoDesc":true}')}}]);