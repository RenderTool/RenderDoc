"use strict";(self.webpackChunkrenderdoc=self.webpackChunkrenderdoc||[]).push([[7103],{33941:(e,a,n)=>{n.r(a),n.d(a,{comp:()=>N,data:()=>j});var t=n(20641);const s=n.p+"assets/img/inv041.540f3cd5.png",i=n.p+"assets/img/inv042.cc1eb43b.png",l=n.p+"assets/img/inv043.20b1442c.png",o=n.p+"assets/img/inv044.86f917c6.png",c=n.p+"assets/img/inv046.c1a11150.png",p=n.p+"assets/img/inv045.c8ea74d6.png",k=n.p+"assets/img/inv047.bd1b3dce.png",r=n.p+"assets/img/inv048.4777e431.png",u=(0,t.Lk)("figure",null,[(0,t.Lk)("img",{src:s,alt:"",tabindex:"0",loading:"lazy"}),(0,t.Lk)("figcaption")],-1),d=(0,t.Lk)("figure",null,[(0,t.Lk)("img",{src:i,alt:"",tabindex:"0",loading:"lazy"}),(0,t.Lk)("figcaption")],-1),g=(0,t.Lk)("h3",{id:"rpc可靠性",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#rpc可靠性"},[(0,t.Lk)("span",null,"RPC可靠性")])],-1),L=(0,t.Lk)("figure",null,[(0,t.Lk)("img",{src:l,alt:"",tabindex:"0",loading:"lazy"}),(0,t.Lk)("figcaption")],-1),h=(0,t.Lk)("figure",null,[(0,t.Lk)("img",{src:o,alt:"",tabindex:"0",loading:"lazy"}),(0,t.Lk)("figcaption")],-1),m=(0,t.Lk)("blockquote",null,[(0,t.Lk)("p",null,"SkeletalMeshComponent（继承自 SkinnedMeshComponent）及其 SkeletalMesh 都不会复制。")],-1),f=(0,t.Lk)("h3",{id:"repnotify",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#repnotify"},[(0,t.Lk)("span",null,"RepNotify")])],-1),b=(0,t.Lk)("p",null,"用一个复制变量通知即可.",-1),v=(0,t.Lk)("figure",null,[(0,t.Lk)("img",{src:c,alt:"",tabindex:"0",loading:"lazy"}),(0,t.Lk)("figcaption")],-1),W=(0,t.Lk)("p",null,[(0,t.eW)("这个"),(0,t.Lk)("code",null,"子组件"),(0,t.eW)("并不需要设置复制。但要保证这个父Actor要启用复制！")],-1),y=(0,t.Lk)("figure",null,[(0,t.Lk)("img",{src:p,alt:"",tabindex:"0",loading:"lazy"}),(0,t.Lk)("figcaption")],-1),M=(0,t.Lk)("h3",{id:"has-authority",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#has-authority"},[(0,t.Lk)("span",null,"Has Authority")])],-1),C=(0,t.Lk)("figure",null,[(0,t.Lk)("img",{src:k,alt:"",tabindex:"0",loading:"lazy"}),(0,t.Lk)("figcaption")],-1),_=(0,t.Lk)("p",null,"事实上，你可以依托某些同生命周期的变量去实现这个，例如一些服务器生成的道具，假设我们设定道具品质一般生成什么样就是什么样。 借用这个品质的等级Int32变量同步时触发初始化函数。当然直接网格物体本身改成OnRep也是可以的",-1),x=(0,t.Lk)("figure",null,[(0,t.Lk)("img",{src:r,alt:"",tabindex:"0",loading:"lazy"}),(0,t.Lk)("figcaption")],-1),R=(0,t.Lk)("div",{class:"language-cpp line-numbers-mode","data-ext":"cpp","data-title":"cpp"},[(0,t.Lk)("pre",{class:"language-cpp"},[(0,t.Lk)("code",null,[(0,t.Lk)("span",{class:"token function"},"UPROPERTY"),(0,t.Lk)("span",{class:"token punctuation"},"("),(0,t.eW)("ReplicatedUsing"),(0,t.Lk)("span",{class:"token operator"},"="),(0,t.eW)("OnRep_Mesh"),(0,t.Lk)("span",{class:"token punctuation"},")"),(0,t.eW)("\nUSkeletalMesh"),(0,t.Lk)("span",{class:"token operator"},"*"),(0,t.eW)(" Mesh"),(0,t.Lk)("span",{class:"token punctuation"},";"),(0,t.eW)("\n\n"),(0,t.Lk)("span",{class:"token function"},"UFUNCTION"),(0,t.Lk)("span",{class:"token punctuation"},"("),(0,t.Lk)("span",{class:"token punctuation"},")"),(0,t.eW)("\n"),(0,t.Lk)("span",{class:"token keyword"},"void"),(0,t.eW)(),(0,t.Lk)("span",{class:"token function"},"OnRep_Mesh"),(0,t.Lk)("span",{class:"token punctuation"},"("),(0,t.Lk)("span",{class:"token punctuation"},")"),(0,t.Lk)("span",{class:"token punctuation"},";"),(0,t.eW)("\n\n")])]),(0,t.Lk)("div",{class:"line-numbers","aria-hidden":"true"},[(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"})])],-1),S=(0,t.Lk)("div",{class:"language-cpp line-numbers-mode","data-ext":"cpp","data-title":"cpp"},[(0,t.Lk)("pre",{class:"language-cpp"},[(0,t.Lk)("code",null,[(0,t.eW)("\n"),(0,t.Lk)("span",{class:"token keyword"},"void"),(0,t.eW)(),(0,t.Lk)("span",{class:"token class-name"},"AMyCharacter"),(0,t.Lk)("span",{class:"token double-colon punctuation"},"::"),(0,t.Lk)("span",{class:"token function"},"SetMesh"),(0,t.Lk)("span",{class:"token punctuation"},"("),(0,t.eW)("USkeletalMesh"),(0,t.Lk)("span",{class:"token operator"},"*"),(0,t.eW)(" NewMesh"),(0,t.Lk)("span",{class:"token punctuation"},")"),(0,t.eW)("\n"),(0,t.Lk)("span",{class:"token punctuation"},"{"),(0,t.eW)("\n    Mesh "),(0,t.Lk)("span",{class:"token operator"},"="),(0,t.eW)(" NewMesh"),(0,t.Lk)("span",{class:"token punctuation"},";"),(0,t.eW)("\n    "),(0,t.Lk)("span",{class:"token function"},"OnRep_Mesh"),(0,t.Lk)("span",{class:"token punctuation"},"("),(0,t.Lk)("span",{class:"token punctuation"},")"),(0,t.Lk)("span",{class:"token punctuation"},";"),(0,t.eW)("\n"),(0,t.Lk)("span",{class:"token punctuation"},"}"),(0,t.eW)("\n\n"),(0,t.Lk)("span",{class:"token keyword"},"void"),(0,t.eW)(),(0,t.Lk)("span",{class:"token class-name"},"AMyCharacter"),(0,t.Lk)("span",{class:"token double-colon punctuation"},"::"),(0,t.Lk)("span",{class:"token function"},"OnRep_Mesh"),(0,t.Lk)("span",{class:"token punctuation"},"("),(0,t.Lk)("span",{class:"token punctuation"},")"),(0,t.eW)("\n"),(0,t.Lk)("span",{class:"token punctuation"},"{"),(0,t.eW)("\n    "),(0,t.Lk)("span",{class:"token function"},"GetMesh"),(0,t.Lk)("span",{class:"token punctuation"},"("),(0,t.Lk)("span",{class:"token punctuation"},")"),(0,t.Lk)("span",{class:"token operator"},"->"),(0,t.Lk)("span",{class:"token function"},"SetSkeletalMesh"),(0,t.Lk)("span",{class:"token punctuation"},"("),(0,t.eW)("Mesh"),(0,t.Lk)("span",{class:"token punctuation"},")"),(0,t.Lk)("span",{class:"token punctuation"},";"),(0,t.eW)("\n"),(0,t.Lk)("span",{class:"token punctuation"},"}"),(0,t.eW)("\n\n")])]),(0,t.Lk)("div",{class:"line-numbers","aria-hidden":"true"},[(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"}),(0,t.Lk)("div",{class:"line-number"})])],-1),F={},N=(0,n(66262).A)(F,[["render",function(e,a){const n=(0,t.g2)("chatmessage"),s=(0,t.g2)("gifwithbutton"),i=(0,t.g2)("CodeTabs");return(0,t.uX)(),(0,t.CE)("div",null,[(0,t.bF)(n,{avatar:"../../assets/emoji/hx.png",avatarWidth:40},{default:(0,t.k6)((()=>[(0,t.eW)(" 静态网格物体，我在服务器上执行生成行为，只要Actor组件和这个子组件设置同步就能同步。 ")])),_:1}),u,(0,t.bF)(n,{avatar:"../../assets/emoji/hx.png",avatarWidth:40},{default:(0,t.k6)((()=>[(0,t.eW)(" 为什么同样的方法却骨骼网格物体看不到同步结果？ ")])),_:1}),d,g,(0,t.bF)(n,{avatar:"../../assets/emoji/hx.png",avatarWidth:40},{default:(0,t.k6)((()=>[(0,t.eW)(" 然后我用了RPC去实现 ")])),_:1}),L,(0,t.bF)(n,{avatar:"../../assets/emoji/hx.png",avatarWidth:40},{default:(0,t.k6)((()=>[(0,t.eW)(" 依然没有同步！ ")])),_:1}),h,m,(0,t.bF)(n,{avatar:"../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:(0,t.k6)((()=>[(0,t.eW)(" 这个问题其实和延迟有关系。虽然你同时启用了服务端和客户端，但他们始终有个创建和加入的先后顺序。 ")])),_:1}),(0,t.bF)(s,{src:"../../assets/unrealgif/hpup31.gif"}),(0,t.bF)(n,{avatar:"../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:(0,t.k6)((()=>[(0,t.eW)(" 更何况真实情况中的中途加入/断线重连等。 ")])),_:1}),(0,t.bF)(n,{avatar:"../../assets/emoji/hx.png",avatarWidth:40},{default:(0,t.k6)((()=>[(0,t.eW)(" 那该怎么解决？ ")])),_:1}),f,(0,t.bF)(n,{avatar:"../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:(0,t.k6)((()=>[b])),_:1}),v,(0,t.bF)(n,{avatar:"../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:(0,t.k6)((()=>[W])),_:1}),y,(0,t.bF)(s,{src:"../../assets/unrealgif/hpup32.gif"}),(0,t.bF)(n,{avatar:"../../assets/emoji/hx.png",avatarWidth:40},{default:(0,t.k6)((()=>[(0,t.eW)(" 这和我们上一篇强化认知中的OnRep异曲同工！ ")])),_:1}),M,(0,t.bF)(n,{avatar:"../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:(0,t.k6)((()=>[(0,t.eW)(" 对于非玩家物体，甚至可以直接用是否拥有权限来过滤远程 ")])),_:1}),C,(0,t.bF)(n,{avatar:"../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:(0,t.k6)((()=>[_])),_:1}),x,(0,t.bF)(i,{id:"66",data:[{id:".h"},{id:".cpp"}],"tab-id":"language"},{title0:(0,t.k6)((({value:e,isActive:a})=>[(0,t.eW)(".h")])),title1:(0,t.k6)((({value:e,isActive:a})=>[(0,t.eW)(".cpp")])),tab0:(0,t.k6)((({value:e,isActive:a})=>[R])),tab1:(0,t.k6)((({value:e,isActive:a})=>[S])),_:1},8,["data"])])}]]),j=JSON.parse('{"path":"/unreal/network_%E7%BD%91%E7%BB%9C_/2.2.1GamePlayNetWork.html","title":"NT-2.2.1|复制延迟","lang":"zh-CN","frontmatter":{"title":"NT-2.2.1|复制延迟","order":23,"category":["u++"],"description":"RPC可靠性 SkeletalMeshComponent（继承自 SkinnedMeshComponent）及其 SkeletalMesh 都不会复制。","head":[["meta",{"property":"og:url","content":"https://rendertool.github.io/RenderDoc/unreal/network_%E7%BD%91%E7%BB%9C_/2.2.1GamePlayNetWork.html"}],["meta",{"property":"og:site_name","content":"RenderDoc"}],["meta",{"property":"og:title","content":"NT-2.2.1|复制延迟"}],["meta",{"property":"og:description","content":"RPC可靠性 SkeletalMeshComponent（继承自 SkinnedMeshComponent）及其 SkeletalMesh 都不会复制。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-25T23:34:33.000Z"}],["meta",{"property":"article:author","content":"Mr.Si"}],["meta",{"property":"article:modified_time","content":"2024-10-25T23:34:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"NT-2.2.1|复制延迟\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-25T23:34:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Si\\",\\"url\\":\\"https://rendertool.github.io/RenderDoc/\\"}]}"]]},"headers":[{"level":3,"title":"RPC可靠性","slug":"rpc可靠性","link":"#rpc可靠性","children":[]},{"level":3,"title":"RepNotify","slug":"repnotify","link":"#repnotify","children":[]},{"level":3,"title":"Has Authority","slug":"has-authority","link":"#has-authority","children":[]}],"git":{"createdTime":1710945776000,"updatedTime":1729899273000,"contributors":[{"name":"sigaohe","email":"750831855@qq.com","commits":2}]},"readingTime":{"minutes":1.68,"words":505},"filePathRelative":"unreal/network[网络]/2.2.1GamePlayNetWork.md","localizedDate":"2024年3月20日","excerpt":"\\n<figure><figcaption></figcaption></figure>\\n\\n<figure><figcaption></figcaption></figure>\\n<h3>RPC可靠性</h3>\\n\\n<figure><figcaption></figcaption></figure>\\n\\n<figure><figcaption></figcaption></figure>\\n<blockquote>\\n<p>SkeletalMeshComponent（继承自 SkinnedMeshComponent）及其 SkeletalMesh 都不会复制。</p>\\n</blockquote>\\n\\n","autoDesc":true}')}}]);