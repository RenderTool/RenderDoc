"use strict";(self.webpackChunkrenderdoc=self.webpackChunkrenderdoc||[]).push([[4241],{51758:(t,e,d)=>{d.r(e),d.d(e,{comp:()=>y,data:()=>k});var a=d(20641);const i=d.p+"assets/img/HighresScreenshot00000.fc348969.png",n=d.p+"assets/img/pose001.a7a34e55.png",r=d.p+"assets/img/pose002.2d796efb.png",o=d.p+"assets/img/pose003.5953d739.png",l=d.p+"assets/img/pose005.35925ffe.png",g=d.p+"assets/img/pose004.c5e36abc.png",s=d.p+"assets/img/pose006.787ea959.jpg",c=(0,a.Lk)("figure",null,[(0,a.Lk)("img",{src:i,alt:"",tabindex:"0",loading:"lazy"}),(0,a.Lk)("figcaption")],-1),p=(0,a.Lk)("h2",{id:"准备",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#准备"},[(0,a.Lk)("span",null,"准备")])],-1),h=(0,a.Lk)("figure",null,[(0,a.Lk)("img",{src:n,alt:"",tabindex:"0",loading:"lazy"}),(0,a.Lk)("figcaption")],-1),m=(0,a.Lk)("h3",{id:"_1d混合空间",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#_1d混合空间"},[(0,a.Lk)("span",null,"1D混合空间")])],-1),u=(0,a.Lk)("figure",null,[(0,a.Lk)("img",{src:r,alt:"",tabindex:"0",loading:"lazy"}),(0,a.Lk)("figcaption")],-1),f=(0,a.Lk)("h3",{id:"应用网格体空间叠加型姿势-apply-mesh-space-additive",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#应用网格体空间叠加型姿势-apply-mesh-space-additive"},[(0,a.Lk)("span",null,"应用网格体空间叠加型姿势（Apply Mesh Space Additive）")])],-1),b=(0,a.Lk)("figure",null,[(0,a.Lk)("img",{src:o,alt:"",tabindex:"0",loading:"lazy"}),(0,a.Lk)("figcaption")],-1),A=(0,a.Fv)('<figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+g+'" alt="Get Lean Amount" tabindex="0" loading="lazy"><figcaption>Get Lean Amount</figcaption></figure><figure><img src="'+s+'" alt="Calculate Relative Acceleration Amount" tabindex="0" loading="lazy"><figcaption>Calculate Relative Acceleration Amount</figcaption></figure><h3 id="其他混合技术" tabindex="-1"><a class="header-anchor" href="#其他混合技术"><span>其他混合技术</span></a></h3><h1 id="动画混合技术对比表" tabindex="-1"><a class="header-anchor" href="#动画混合技术对比表"><span>动画混合技术对比表</span></a></h1><table><thead><tr><th>​<strong>技术类型</strong>​</th><th>​<strong>子技术</strong>​</th><th>​<strong>核心原理</strong>​</th><th>​<strong>适用场景</strong>​</th><th>​<strong>典型工具/代码示例</strong>​</th></tr></thead><tbody><tr><td>​<strong>时间轴混合</strong>​</td><td>线性混合 (Linear Blending)</td><td>对两个动画片段的关键帧进行线性插值。</td><td>简单状态切换（如站立即走）</td><td><code>cpp&lt;br&gt;// Unreal Engine权重线性插值&lt;br&gt;float BlendWeight = FMath::Lerp(StartWeight, EndWeight, Alpha);</code></td></tr><tr><td></td><td>平滑混合 (Smooth Blending)</td><td>引入加速度参数模拟物理惯性，权重按指数衰减。</td><td>角色移动过渡（奔跑→滑步→静止）</td><td><code>cpp&lt;br&gt;// 指数衰减权重计算&lt;br&gt;BlendWeight = Initial * FMath::Exp(-DecayRate * DeltaTime);</code></td></tr><tr><td>​<strong>空间变换混合</strong>​</td><td>方向形变 (Orientation Warping)</td><td>根据目标方向调整骨骼旋转（如横滑时的足部偏移）。</td><td>运动匹配中的横向滑步补偿</td><td><code>cpp&lt;br&gt;// UE4方向形变节点配置&lt;br&gt;SetWarpTargetDirection(LocomotionDirection);</code></td></tr><tr><td></td><td>位置混合 (Position Blending)</td><td>叠加多个动画的位置数据，修正地面碰撞后的滑动。</td><td>物理交互（被击飞后的落地缓冲）</td><td><code>csharp&lt;br&gt;// Unity位置混合逻辑&lt;br&gt;transform.position = Vector3.Lerp(currentPos, targetPos, BlendFactor);</code></td></tr><tr><td>​<strong>物理驱动混合</strong>​</td><td>惯性混合 (Inertia Blending)</td><td>通过质量、速度和加速度动态调整动画权重，模拟真实惯性。</td><td>高速移动后的减速（急停、转弯）</td><td><code>cpp&lt;br&gt;// 物理惯性混合公式&lt;br&gt;v(t) = v0 * e^(-λt) + (F/m)(1 - e^(-λt));</code></td></tr><tr><td></td><td>动量混合 (Momentum Blending)</td><td>保留运动动量信息，延长状态切换的平滑时间。</td><td>物理驱动动画（角色被推飞轨迹延续）</td><td><code>python&lt;br&gt;// PyBullet动量混合示例&lt;br&gt;apply_linear_impulse(body_id, momentum_x, momentum_y, momentum_z);</code></td></tr><tr><td>​<strong>层级混合</strong>​</td><td>基础层+叠加层 (Base + Additive)</td><td>通过权重控制基础动画与额外动画的叠加强度（如武器摆动叠加在身体动画上）。</td><td>武器/表情等局部效果添加</td><td><code>unreal&lt;br&gt;// UE4叠加层权重设置&lt;br&gt;SetAdditiveLayerWeight(&quot;ArmWeapons&quot;, 0.5f);</code></td></tr><tr><td></td><td>遮罩混合 (Masked Blending)</td><td>通过骨骼遮罩限制叠加层的作用范围（如仅腿部添加滑行动画）。</td><td>局部动画调整（如滑行腿部特效）</td><td><code>unreal&lt;br&gt;// 设置骨骼遮罩&lt;br&gt;SetBoneMask(BoneMask, EAnimCurveTypes::Additive);</code></td></tr><tr><td>​<strong>动画状态机混合</strong>​</td><td>交叉淡入淡出 (Crossfade Blending)</td><td>在两个动画间渐变权重，避免突兀切换。</td><td>复杂动作过渡（走→跑→跳）</td><td><code>unreal&lt;br&gt;// UE4状态机过渡设置&lt;br&gt;AddTransition(FromState, ToState, TransitionTime);</code></td></tr><tr><td></td><td>死区混合 (Dead Blending)</td><td>插入“死区”时间，忽略短时间内的突变输入，防止高频切换抖动。</td><td>快速动作序列（战斗技能连招）</td><td><code>csharp&lt;br&gt;// Unity死区混合检测&lt;br&gt;if (InputVelocity.SquaredLength() &lt; Threshold) { DeadZoneTime += DeltaTime;}</code></td></tr><tr><td>​<strong>AI与数据驱动混合</strong>​</td><td>动捕后期处理 (Motion Capture Post-Processing)</td><td>使用工具（如Mixamo）自动平滑过渡帧。</td><td>修复原始动捕数据的突兀动作</td><td><code>mixamo&lt;br&gt;// Mixamo平滑工具参数设置&lt;br&gt;Smoothness: 0.8; Transition Time: 0.3s;</code></td></tr><tr><td></td><td>神经混合 (Neural Blending)</td><td>训练AI模型预测最佳过渡动画（如Meta的AnimateDiffusion）。</td><td>复杂交互场景（未知动作类型生成）</td><td><code>python&lt;br}// 神经网络训练伪代码&lt;br&gt;model.train(transition_data, epochs=100);</code></td></tr><tr><td>​<strong>变形混合</strong>​</td><td>混合形状 (Blend Shapes)</td><td>通过顶点形状权重叠加实现面部表情或体型变化。</td><td>角色个性化（不同角色的体型差异）</td><td><code>unreal&lt;br}// UE4BlendShapes权重调整&lt;br&gt;SkeletalMeshComponent-&gt;SetBlendShapeWeight(ShapeIndex, Value);</code></td></tr><tr><td></td><td>骨骼变形 (Skeletal Deformation)</td><td>在骨骼动画基础上叠加形变效果（如衣服随动作摆动）。</td><td>衣物/软体物理模拟</td><td><code>glsl&lt;br&gt;// GLSL顶点着色器变形逻辑&lt;br&gt;varying vec3 deformedPos = originalPos + (boneTransform * deformationVector);</code></td></tr></tbody></table><hr>',7),v={},y=(0,d(66262).A)(v,[["render",function(t,e){const d=(0,a.g2)("chatmessage");return(0,a.uX)(),(0,a.CE)("div",null,[(0,a.bF)(d,{avatar:"../../assets/emoji/hh.png",avatarWidth:40},{default:(0,a.k6)((()=>[(0,a.eW)(" Baba!我想让我的角色跑起来时身体有明显的运动倾斜。 ")])),_:1}),c,(0,a.bF)(d,{avatar:"../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:(0,a.k6)((()=>[(0,a.eW)(" 安排！ ")])),_:1}),p,(0,a.bF)(d,{avatar:"../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:(0,a.k6)((()=>[(0,a.eW)(" 准备3个Pose，左中右。 ")])),_:1}),h,m,(0,a.bF)(d,{avatar:"../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:(0,a.k6)((()=>[(0,a.eW)(" 将上面的3个Pose放入。 ")])),_:1}),u,(0,a.bF)(d,{avatar:"../../assets/emoji/hh.png",avatarWidth:40},{default:(0,a.k6)((()=>[(0,a.eW)(" 妙啊！通过-1到1的值映射左中右3个Pose的动作幅度。 ")])),_:1}),f,b,(0,a.bF)(d,{avatar:"../../assets/emoji/bqb (2).png",avatarWidth:40,alignLeft:""},{default:(0,a.k6)((()=>[(0,a.eW)(" 在不破坏原有动作的前提下，Space Additive能通过条件自动叠加混合出我们需要的姿势。 ")])),_:1}),A])}]]),k=JSON.parse('{"path":"/unreal/exp_%E7%BB%8F%E9%AA%8C_/8-SpaceAdditive.html","title":"EXP8.SpaceAdditive","lang":"zh-CN","frontmatter":{"title":"EXP8.SpaceAdditive","order":"08","category":["u++"],"description":"准备 1D混合空间 应用网格体空间叠加型姿势（Apply Mesh Space Additive） Get Lean AmountGet Lean Amount Calculate Relative Acceleration AmountCalculate Relative Acceleration Amount 其他混合技术 动画混合技术对比表","head":[["meta",{"property":"og:url","content":"https://rendertool.github.io/RenderDoc/unreal/exp_%E7%BB%8F%E9%AA%8C_/8-SpaceAdditive.html"}],["meta",{"property":"og:site_name","content":"RenderDoc"}],["meta",{"property":"og:title","content":"EXP8.SpaceAdditive"}],["meta",{"property":"og:description","content":"准备 1D混合空间 应用网格体空间叠加型姿势（Apply Mesh Space Additive） Get Lean AmountGet Lean Amount Calculate Relative Acceleration AmountCalculate Relative Acceleration Amount 其他混合技术 动画混合技术对比表"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-08T09:31:05.000Z"}],["meta",{"property":"article:author","content":"Mr.Si"}],["meta",{"property":"article:modified_time","content":"2025-03-08T09:31:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"EXP8.SpaceAdditive\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-08T09:31:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Si\\",\\"url\\":\\"https://rendertool.github.io/RenderDoc/\\"}]}"]]},"headers":[{"level":2,"title":"准备","slug":"准备","link":"#准备","children":[{"level":3,"title":"1D混合空间","slug":"_1d混合空间","link":"#_1d混合空间","children":[]},{"level":3,"title":"应用网格体空间叠加型姿势（Apply Mesh Space Additive）","slug":"应用网格体空间叠加型姿势-apply-mesh-space-additive","link":"#应用网格体空间叠加型姿势-apply-mesh-space-additive","children":[]},{"level":3,"title":"其他混合技术","slug":"其他混合技术","link":"#其他混合技术","children":[]}]}],"git":{"createdTime":1719390005000,"updatedTime":1741426265000,"contributors":[{"name":"sigaohe","email":"750831855@qq.com","commits":3}]},"readingTime":{"minutes":3.57,"words":1072},"filePathRelative":"unreal/exp[经验]/8-SpaceAdditive.md","localizedDate":"2024年6月26日","excerpt":"\\n<figure><figcaption></figcaption></figure>\\n\\n<h2>准备</h2>\\n\\n<figure><figcaption></figcaption></figure>\\n<h3>1D混合空间</h3>\\n\\n<figure><figcaption></figcaption></figure>\\n\\n<h3>应用网格体空间叠加型姿势（Apply Mesh Space Additive）</h3>\\n<figure><figcaption></figcaption></figure>\\n\\n<figure><figcaption></figcaption></figure>\\n<figure><figcaption>Get Lean Amount</figcaption></figure>","autoDesc":true}')}}]);