const e=JSON.parse('{"key":"v-6d26eac0","path":"/language/cpp/stl_%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF_/3-vector.html","title":"c++3.vector容器","lang":"zh-CN","frontmatter":{"title":"c++3.vector容器","order":3,"category":["c++"],"description":"vector 静态空间 vs. 动态扩展： 数组：在定义时，数组的大小就已经固定，它占据静态的空间，无法在运行时改变大小。数组的大小是在编译时确定的。 std::vector：std::vector 是一个动态数组的实现，它可以在运行时动态扩展。这意味着 std::vector 的大小可以根据需要动态增加或减少，而不需要手动管理内存。 动态扩展的实现： 当 std::vector 的容量不足以容纳新元素时，它会请求更大的内存块。这通常涉及到分配一块新的内存空间，将原有元素拷贝到新的内存中，然后释放原有的内存。这个过程确保了内存的连续性，有助于提高访问效率。 遵循左闭右开原则","head":[["meta",{"property":"og:url","content":"https://rendertool.github.io/RenderDoc/RenderDoc/language/cpp/stl_%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF_/3-vector.html"}],["meta",{"property":"og:site_name","content":"RenderDoc"}],["meta",{"property":"og:title","content":"c++3.vector容器"}],["meta",{"property":"og:description","content":"vector 静态空间 vs. 动态扩展： 数组：在定义时，数组的大小就已经固定，它占据静态的空间，无法在运行时改变大小。数组的大小是在编译时确定的。 std::vector：std::vector 是一个动态数组的实现，它可以在运行时动态扩展。这意味着 std::vector 的大小可以根据需要动态增加或减少，而不需要手动管理内存。 动态扩展的实现： 当 std::vector 的容量不足以容纳新元素时，它会请求更大的内存块。这通常涉及到分配一块新的内存空间，将原有元素拷贝到新的内存中，然后释放原有的内存。这个过程确保了内存的连续性，有助于提高访问效率。 遵循左闭右开原则"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-02T22:07:13.000Z"}],["meta",{"property":"article:author","content":"Mr.Si"}],["meta",{"property":"article:modified_time","content":"2024-01-02T22:07:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"c++3.vector容器\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-01-02T22:07:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Si\\",\\"url\\":\\"https://rendertool.github.io/RenderDoc/\\"}]}"]]},"headers":[{"level":3,"title":"vector","slug":"vector","link":"#vector","children":[]},{"level":3,"title":"实例化vector","slug":"实例化vector","link":"#实例化vector","children":[]},{"level":3,"title":"基本方法","slug":"基本方法","link":"#基本方法","children":[]},{"level":3,"title":"迭代器","slug":"迭代器","link":"#迭代器","children":[]},{"level":3,"title":"问题","slug":"问题","link":"#问题","children":[]},{"level":3,"title":"3. front和begin区别","slug":"_3-front和begin区别","link":"#_3-front和begin区别","children":[]},{"level":3,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1701893836000,"updatedTime":1704233233000,"contributors":[{"name":"admin","email":"750831855@qq.com","commits":2},{"name":"sigaohe","email":"750831855@qq.com","commits":1}]},"readingTime":{"minutes":5.28,"words":1583},"filePathRelative":"language/cpp/stl[标准模板]/3-vector.md","localizedDate":"2023年12月6日","excerpt":"<h3> vector</h3>\\n\\n\\n\\n<ol>\\n<li>\\n<p><strong>静态空间 vs. 动态扩展</strong>：</p>\\n<ul>\\n<li><strong>数组</strong>：在定义时，数组的大小就已经固定，它占据静态的空间，无法在运行时改变大小。数组的大小是在编译时确定的。</li>\\n<li><strong><code>std::vector</code></strong>：<code>std::vector</code> 是一个动态数组的实现，它可以在运行时动态扩展。这意味着 <code>std::vector</code> 的大小可以根据需要动态增加或减少，而不需要手动管理内存。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>动态扩展的实现</strong>：</p>\\n<ul>\\n<li>当 <code>std::vector</code> 的容量不足以容纳新元素时，它会请求更大的内存块。这通常涉及到分配一块新的内存空间，将原有元素拷贝到新的内存中，然后释放原有的内存。这个过程确保了内存的连续性，有助于提高访问效率。</li>\\n<li>遵循左闭右开原则</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}');export{e as data};
