import{_ as d,r as c,o as r,c as u,d as e,w as a,a as s,b as n,e as p}from"./app-6eaee12a.js";const k="/RenderDoc/assets/dequevector-296fc124.png",v="/RenderDoc/assets/dequesx-9e93dc73.png",g={},m=s("h3",{id:"deque",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#deque","aria-hidden":"true"},"#"),n(" deque")],-1),h=s("figure",null,[s("img",{src:k,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),_=s("h3",{id:"std-deque-定义",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#std-deque-定义","aria-hidden":"true"},"#"),n(),s("code",null,"std::deque"),n(" 定义：")],-1),b=s("p",null,[s("code",null,"std::deque"),n("（双端队列Double Ended Queue）是 C++ 标准库中的容器，它允许在两端高效地进行插入和删除操作。")],-1),q=s("div",{class:"language-cpp line-numbers-mode","data-ext":"cpp"},[s("pre",{class:"language-cpp"},[s("code",null,[s("span",{class:"token macro property"},[s("span",{class:"token directive-hash"},"#"),s("span",{class:"token directive keyword"},"include"),n(),s("span",{class:"token string"},"<deque>")]),n(`

std`),s("span",{class:"token double-colon punctuation"},"::"),n("deque"),s("span",{class:"token operator"},"<"),s("span",{class:"token keyword"},"int"),s("span",{class:"token operator"},">"),n(" myDeque"),s("span",{class:"token punctuation"},";"),n(),s("span",{class:"token comment"},"// 创建一个存储 int 类型的双端队列"),n(`
`)])]),s("div",{class:"line-numbers","aria-hidden":"true"},[s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"})])],-1),f=s("div",{class:"language-cpp line-numbers-mode","data-ext":"cpp"},[s("pre",{class:"language-cpp"},[s("code",null,[s("span",{class:"token keyword"},"template"),n(),s("span",{class:"token operator"},"<"),n(),s("span",{class:"token keyword"},"class"),n(),s("span",{class:"token class-name"},"T"),s("span",{class:"token punctuation"},","),n(),s("span",{class:"token keyword"},"class"),n(),s("span",{class:"token class-name"},"Alloc"),n(),s("span",{class:"token operator"},"="),n(" allocator"),s("span",{class:"token operator"},"<"),n("T"),s("span",{class:"token operator"},">"),n(),s("span",{class:"token operator"},">"),n(),s("span",{class:"token keyword"},"class"),n(),s("span",{class:"token class-name"},"deque"),s("span",{class:"token punctuation"},";"),n(`
`)])]),s("div",{class:"line-numbers","aria-hidden":"true"},[s("div",{class:"line-number"})])],-1),y=s("figure",null,[s("img",{src:v,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),w=s("p",null,[n("看来你还是停留在普通数组的for遍历实现阶段上，咱们已经说了几乎每个容器都有自己的迭代器，"),s("code",null,"std::deque"),n(" 也提供了迭代器（iterator）来进行遍历，迭代器会隐藏底层的实现细节，使得用户无需关心具体的内存结构。")],-1),x=p(`<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;deque&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> myDeque <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 使用迭代器遍历</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> myDeque<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> myDeque<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),j=s("p",null,[n("顺带提的是，"),s("code",null,"deque"),n("由于用到了中控器，意味着他的执行访问效率是没有"),s("code",null,"vector"),n("高的。")],-1),W=p('<h3 id="deque-vs-ector" tabindex="-1"><a class="header-anchor" href="#deque-vs-ector" aria-hidden="true">#</a> deque VS ector</h3><ol><li><p><strong>动态内存管理</strong>：</p><ul><li><strong><code>std::vector</code></strong>：<code>std::vector</code> 是一个动态数组，元素存储在连续的内存块中，只能在数组的末尾进行快速的插入和删除。当容量不足时，可能需要重新分配内存。</li><li><strong><code>std::deque</code></strong>：<code>std::deque</code> 也是动态数组，但它允许在两端进行快速的插入和删除操作。<code>std::deque</code> 使用块状分配内存，每个块中包含多个元素，这有助于减少重新分配内存的次数。</li></ul></li><li><p><strong>内存结构</strong>：</p><ul><li><strong><code>std::vector</code></strong>：元素在内存中是连续存储的，因此访问元素的速度较快。</li><li><strong><code>std::deque</code></strong>：元素可能存储在多个块中，因此内存不一定是连续的。但由于块的数量相对较小，访问元素的速度仍然可以维持在一个合理的范围内。</li></ul></li><li><p><strong>效率</strong>：</p><ul><li><strong><code>std::vector</code></strong>：在末尾进行操作的效率非常高，但在头部进行插入和删除时可能比较慢，因为需要移动大量元素。</li><li><strong><code>std::deque</code></strong>：在两端进行操作的效率都比较高，因为它使用了块状分配，减少了元素的移动。</li></ul></li><li><p><strong>迭代器的失效问题</strong>：</p><ul><li><strong><code>std::vector</code></strong>：由于元素的连续存储，插入或删除元素可能导致迭代器失效。</li><li><strong><code>std::deque</code></strong>：在两端进行插入或删除不会导致迭代器失效，因为块之间的元素位置关系不会改变。</li></ul></li></ol><h3 id="中控区" tabindex="-1"><a class="header-anchor" href="#中控区" aria-hidden="true">#</a> 中控区</h3>',3),D=s("p",null,[n("中控区（Controller）是 "),s("code",null,"std::deque"),n(" 内部用于管理块状结构的一个组件。它本质上是一个数据结构，用于维护对块的引用以及块之间的连接关系。")],-1),B=s("ol",null,[s("li",null,[s("strong",null,"指向前端块的指针（Front Block Pointer）："),n(" 指向双端队列的前端块。")]),s("li",null,[s("strong",null,"指向后端块的指针（Back Block Pointer）："),n(" 指向双端队列的后端块。")]),s("li",null,[s("strong",null,"块的数量信息："),n(" 记录了整个 "),s("code",null,"std::deque"),n(" 中有多少块。")])],-1);function C(L,A){const t=c("chatmessage"),i=c("CodeTabs");return r(),u("div",null,[m,e(t,{avatar:"../../../assets/emoji/hx.png",avatarWidth:40},{default:a(()=>[n(" 前面我们提到了vector是单端数组，遵循左闭右开，那么有没有两边都能插入元素的数组？ ")]),_:1}),e(t,{avatar:"../../../assets/emoji/new9.png",avatarWidth:40,alignLeft:""},{default:a(()=>[n(" 还真有，deque就是一个。 ")]),_:1}),h,_,e(t,{avatar:"../../../assets/emoji/bqb (6).png",avatarWidth:40,alignLeft:""},{default:a(()=>[b]),_:1}),e(i,{id:"16",data:[{id:"实例化"},{id:"标准库中的定义"}],"tab-id":"language"},{title0:a(({value:o,isActive:l})=>[n("实例化")]),title1:a(({value:o,isActive:l})=>[n("标准库中的定义")]),tab0:a(({value:o,isActive:l})=>[q]),tab1:a(({value:o,isActive:l})=>[f]),_:1}),e(t,{avatar:"../../../assets/emoji/hx.png",avatarWidth:40},{default:a(()=>[n(" 我不理解，vector是连续内存空间，导致不能头部插入新元素，那么deque却可以，他是如何实现的呢？ ")]),_:1}),e(t,{avatar:"../../../assets/emoji/bqb (6).png",avatarWidth:40,alignLeft:""},{default:a(()=>[n(" 因为他用到了中控器（controller）来管理块状结构。这个中控器负责维护对块的引用以及块之间的连接关系。每个块内部的元素是连续存储的，但不同块之间的元素不一定是连续的。 ")]),_:1}),y,e(t,{avatar:"../../../assets/emoji/hx.png",avatarWidth:40},{default:a(()=>[n(" 问题来了，那么我怎么遍历呢？你都不是连续空间了！ ")]),_:1}),e(t,{avatar:"../../../assets/emoji/new2.png",avatarWidth:50,alignLeft:""},{default:a(()=>[w]),_:1}),x,e(t,{avatar:"../../../assets/emoji/new2.png",avatarWidth:50,alignLeft:""},{default:a(()=>[j]),_:1}),W,e(t,{avatar:"../../../assets/emoji/hx.png",avatarWidth:40},{default:a(()=>[n(" 我还是不理解中控区是什么？ ")]),_:1}),e(t,{avatar:"../../../assets/emoji/new2.png",avatarWidth:50,alignLeft:""},{default:a(()=>[D]),_:1}),B])}const V=d(g,[["render",C],["__file","4-deque.html.vue"]]);export{V as default};
