---
title: c8.2GAS|GameplayAbility|Ability专解
order : 802
category:
  - u++
---

## Ability

![](..%2Fassets%2FGASuse006.png)

## 从TryActivateAbility开始

![](..%2Fassets%2Fab001.png)

```cpp
TryActivateAbility(GameplayAbilitySpec.Handle, bAllowRemoteActivation)
```


<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>

激活一个 `GA`，并根据 **网络角色** 和 **能力的 NetExecutionPolicy** 决定执行位置、是否预测、本地是否运行等。

</chatmessage>

![](..%2Fassets%2Fab002.jpg)

![](..%2Fassets%2Fab003.svg)

### NetExecutionPolicy

![](..%2Fassets%2Fab005.png)

| NetExecutionPolicy | 本地调用位置 | 远程调用处理逻辑                        |
|--------------------|--------|---------------------------------|
| `LocalOnly`        | 客户端    | 不允许远程激活                         |
| `LocalPredicted`   | 客户端    | 允许客户端预测 → 发起激活 RPC              |
| `ServerOnly`       | 服务器    | 客户端请求服务器执行 → `CallServerTry...` |
| `ServerInitiated`  | 服务器    | 客户端无法主动触发，必须由服务器调用              |


<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>

默认用到是`LocalPredicted`

</chatmessage>

## InternalServerTryActivateAbility

![](..%2Fassets%2Fab004.svg)

<chatmessage avatar="../../assets/emoji/hx.png" :avatarWidth="40" >

也就说无论是客户端还是服务器最终都会执行一次`InternalServerTryActivateAbility`

</chatmessage>


<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>

没错，主要是用来检测一些触发条件、响应不同的网络策略。

</chatmessage>

```cpp
void UAbilitySystemComponent::ServerTryActivateAbility_Implementation(FGameplayAbilitySpecHandle Handle, bool InputPressed, FPredictionKey PredictionKey)
{
	InternalServerTryActivateAbility(Handle, InputPressed, PredictionKey, nullptr);
}

```

### AbilityInstancingPolicy

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
里面有我们比较熟悉的一个设置，从代码上可知，InstancedPerActor 会尝试复用某个创建好的Handle
</chatmessage>


| 枚举值                             | 含义与用途                                                                                       | 备注                                                                                          |
|----------------------------------|--------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| `NonInstanced`                   | 能力不创建实例。所有调用共享同一个 Ability 类默认对象（CDO）                                  | 高性能、无状态的能力（如纯粹触发效果）；不能调用 EndAbility，不能存储状态                   |
| `InstancedPerActor`             | 每个拥有该能力的 Actor 创建一个实例，激活时复用该实例                                           | 支持存储状态、调用 EndAbility、可以被多个激活流程控制；最常用的策略                          |
| `InstancedPerExecution`         | 每次激活都会创建一个新的 Ability 实例                                                            | 用于需要并发多个激活、每次激活有独立状态的能力（如持续型技能、DOT）                        |

## CallActivateAbility

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
等该做的事都做完以后，包括网络预测键的检测等行为，才会正式开始激活我们的能力。这也是我们激活能力的入口函数之一。后面就是我们比较熟悉的激活流程了
</chatmessage>

```cpp
void UGameplayAbility::CallActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, FOnGameplayAbilityEnded::FDelegate* OnGameplayAbilityEndedDelegate, const FGameplayEventData* TriggerEventData)
{
	PreActivate(Handle, ActorInfo, ActivationInfo, OnGameplayAbilityEndedDelegate, TriggerEventData);
	ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
}
```

```cpp
void UGameplayAbility::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
	if (TriggerEventData && bHasBlueprintActivateFromEvent)
	{
		// A Blueprinted ActivateAbility function must call CommitAbility somewhere in its execution chain.
		K2_ActivateAbilityFromEvent(*TriggerEventData);
	}
	else if (bHasBlueprintActivate)
	{
		// A Blueprinted ActivateAbility function must call CommitAbility somewhere in its execution chain.
		K2_ActivateAbility();
	}
	else if (bHasBlueprintActivateFromEvent)
	{
		UE_LOG(LogAbilitySystem, Warning, TEXT("Ability %s expects event data but none is being supplied. Use 'Activate Ability' instead of 'Activate Ability From Event' in the Blueprint."), *GetName());
		constexpr bool bReplicateEndAbility = false;
		constexpr bool bWasCancelled = true;
		EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
	}
	else
	{
		// Native child classes should override ActivateAbility and call CommitAbility.
		// CommitAbility is used to do one last check for spending resources.
		// Previous versions of this function called CommitAbility but that prevents the callers
		// from knowing the result. Your override should call it and check the result.
		// Here is some starter code:
		
		//	if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
		//	{			
		//		constexpr bool bReplicateEndAbility = true;
		//		constexpr bool bWasCancelled = true;
		//		EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
		//	}
	}
}
```
### CommitAbility

<chatmessage avatar="../../assets/emoji/hx.png" :avatarWidth="40" >

但是我有个疑问啊！`CommitAbility`什么时候执行的？

</chatmessage>


<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>

注释已经写的非常明白了，`CommitAbility`要在`K2_ActivateAbilityFromEvent`后执行，当然C++中习惯在重载`ActivateAbility`中执行

</chatmessage>

```cpp
bool UGameplayAbility::CommitAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, OUT FGameplayTagContainer* OptionalRelevantTags)
{
	// Last chance to fail (maybe we no longer have resources to commit since we after we started this ability activation)
	if (!CommitCheck(Handle, ActorInfo, ActivationInfo, OptionalRelevantTags))
	{
		return false;
	}

	CommitExecute(Handle, ActorInfo, ActivationInfo);

	// Fixme: Should we always call this or only if it is implemented? A noop may not hurt but could be bad for perf (storing a HasBlueprintCommit per instance isn't good either)
	K2_CommitExecute();

	// Broadcast this commitment
	ActorInfo->AbilitySystemComponent->NotifyAbilityCommit(this);

	return true;
}
```

### CommitAbility可选变体

| 函数名                       | 功能说明                                  | 默认行为                                                      |
| ------------------------- | ------------------------------------- | --------------------------------------------------------- |
| `CommitAbility()`         | 尝试提交能力，消耗 GE 资源（如消耗蓝量、加 CD）并应用冷却与花费   | 会同时尝试调用 `CommitAbilityCost()` 和 `CommitAbilityCooldown()` |
| `CommitAbilityCooldown()` | 单独提交冷却效果（Cooldown GE），不处理消耗资源（如 Mana） | 只提交冷却，不提交消耗                                               |
| `CommitAbilityCost()`     | 单独提交资源消耗（Cost GE），不处理冷却               | 只提交资源消耗，不触发冷却                                             |

---
<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>

注意，如果你做技能冷却类的效果，需要手动提交一次`CommitAbilityCooldown()`

</chatmessage>

<chatmessage avatar="../../assets/emoji/hx.png" :avatarWidth="40" >
也就是说这里会主动触发一次我们给定的GE对吧。
</chatmessage>

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
是的，这也是我们实现技能CD、消耗的关键。提到GE不得不提一句，UE5.3后进行了大幅改版。从原来的Config配置模式变成更解决策略模式。
</chatmessage>

![](..%2Fassets%2Fab006.png)

### EndAbility

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>

最后需要通过`EndAbility`结束掉本次GA

</chatmessage>