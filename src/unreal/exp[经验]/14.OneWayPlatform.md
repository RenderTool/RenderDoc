---
title: EXP14.单向跳跃平台(碰撞体积)
order : 14
category:
  - u++
---

## 提要

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
还记得小时候玩的魂斗罗、马里奥这种横板游戏吗？
</chatmessage>

<chatmessage avatar="../../assets/emoji/hx.png" :avatarWidth="40">
当然记得啦！
</chatmessage>

![](..%2Fassets%2Fmlao01.jpg)

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
不知道你有没有注意其中的一个细节。
</chatmessage>

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40">
什么细节?
</chatmessage>

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
你有没有想过，怎么还原这种从下方穿透、上方可以站立的平台？
</chatmessage>

![](..%2Fassets%2Fmlao02.png)

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40">
对哦，如果平台一直开着碰撞，显然我们只能从旁边跳上去。
</chatmessage>

![](..%2Fassets%2Fmlao03.png)

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
而且最重要的是碰撞体积，比如角色胶囊体积对单一物体不会存在既能穿透、又能阻挡的叠加态。
</chatmessage>

<chatmessage avatar="../../assets/emoji/hx.png" :avatarWidth="40">
提到这个我们还是先来回顾一下UE中碰撞体积的一些知识
</chatmessage>

### 响应通道（Collision Response Channels）

![](..%2Fassets%2Fmlao04.png)

---

>UE 的碰撞系统由三部分组成：

1. **碰撞通道（Collision Channel）**

    * 用于标记对象所属类型。
    * UE 内置两种类型：

        * **Object Channels（对象通道）**：标记对象类别，比如 `Pawn`、`WorldStatic`、`WorldDynamic`。
        * **Trace Channels（射线通道）**：用于射线/扫描（LineTrace、SphereTrace）检测。


<chatmessage avatar="../../assets/emoji/hx.png" :avatarWidth="40">

自定义通道（Project Settings → Collision → Object Channels / Trace Channels）。

</chatmessage>


2. **碰撞预设（Collision Presets）**

    * UE 提供常用预设组合，比如：

        * `BlockAll` → 阻挡所有
        * `OverlapAll` → 全部触发重叠事件
        * `Pawn` → 阻挡世界静态物体，忽略玩家等
    * 每个预设内部其实就是 **对每个通道的响应配置**。

3. **碰撞响应（Collision Response）**

    * 决定了对象对某个通道的具体行为：

| 碰撞响应          | 类型 | 描述                                                |
|---------------|----|---------------------------------------------------|
| `ECR_Block`   | 阻挡 | 产生物理碰撞，角色/物体无法穿过                                  |
| `ECR_Overlap` | 重叠 | 允许穿过，但会触发 `OnComponentBeginOverlap/EndOverlap` 事件 |
| `ECR_Ignore`  | 忽略 | 不会碰撞，也不会触发重叠事件                                    |


## 方案

### 方案1

<chatmessage avatar="../../assets/emoji/new7.png" :avatarWidth="40">
我想到的第一个方法是给平台上方加一个触发体积
</chatmessage>

---

* 每个平台上方加一个 **TriggerBox/BoxComponent**（只用于感知角色是否接近）
* 平台默认 **Pawn 通道忽略阻挡**
* 当角色进入 Trigger → 开启 **平台阻挡**（ECR\_Block）
* 当角色离开 Trigger → 关闭阻挡（ECR\_Ignore）

```cpp
APlatformBase::APlatformBase()
{
	PrimaryActorTick.bCanEverTick = false;
	Trigger = CreateDefaultSubobject<UBoxComponent>(TEXT("FootTrigger"));
	Trigger->SetupAttachment(GetRootComponent());
    
	// 设置大小，稍微比脚底大一点
	Trigger->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
	Trigger->SetCollisionResponseToAllChannels(ECR_Overlap);
	Trigger->SetCollisionResponseToChannel(ECC_WorldDynamic, ECR_Overlap);
	Trigger->OnComponentBeginOverlap.AddDynamic(this, &APlatformBase::OnTriggerOverlap);
	Trigger->OnComponentEndOverlap.AddDynamic(this, &APlatformBase::OnTriggerEndOverlap);
}

void APlatformBase::SetBlocking(bool bEnable)
{
	if (bIsBlocking == bEnable) return;

	bIsBlocking = bEnable;
	GetRenderComponent()->SetCollisionResponseToChannel(ECC_Pawn, bEnable ? ECR_Block : ECR_Ignore);
}

void APlatformBase::OnTriggerOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
	UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	if (OtherActor && OtherActor->IsA<ACharacter>())
	{
		SetBlocking(true);
	}
}

void APlatformBase::OnTriggerEndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
	UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	if (OtherActor && OtherActor->IsA<ACharacter>())
	{
		SetBlocking(false);
	}
}
```

---

### 方案1|问题——多角色处理

<chatmessage avatar="../../assets/emoji/new7.png" :avatarWidth="40">
如果是多角色阁下怎么应对？
</chatmessage>


<chatmessage avatar="../../assets/emoji/new2.png" :avatarWidth="50" alignLeft>
这还不简单，直接加一个计数器,记录一下多少角色触碰了就行了。
</chatmessage>

```cpp

// 记录 Trigger 内的角色数量
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Collision")
int32 OverlappingCharacters = 0;

void APlatformBase::OnTriggerOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
	UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	if (OtherActor && OtherActor->IsA<ACharacter>())
	{
		OverlappingCharacters++;
		SetBlocking(true);
	}
}

void APlatformBase::OnTriggerEndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
	UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	if (OtherActor && OtherActor->IsA<ACharacter>())
	{
		OverlappingCharacters = FMath::Max(OverlappingCharacters - 1, 0);
		SetBlocking(false);
	}
}
```

### 方案2|代码

<chatmessage avatar="../../assets/emoji/new7.png" :avatarWidth="35">
当然上面的方案是站在平台角度思考的，我这里其实有一种站在角色本身角度思考的方法。
</chatmessage>

<chatmessage avatar="../../assets/emoji/new2.png" :avatarWidth="50" alignLeft>
说说看。
</chatmessage>

<chatmessage avatar="../../assets/emoji/new7.png" :avatarWidth="35">
反过来，给角色加一个额外的碰撞体积。
</chatmessage>

![](..%2Fassets%2Fmlao06.png)


```cpp

void ADoodleJumpCharacter::OnFootTriggerOverlap(
	UPrimitiveComponent* OverlappedComponent,
	AActor* OtherActor,
	UPrimitiveComponent* OtherComp,
	int32 OtherBodyIndex,
	bool bFromSweep,
	const FHitResult& SweepResult)
{
	if (!OtherActor) return;

	if (APaperFlipbookActor* Platform = Cast<APaperFlipbookActor>(OtherActor))
	{
		const FVector CharLocation = FootTrigger->GetComponentLocation();
		const FVector PlatformLocation = Platform->GetActorLocation();

		if (CharLocation.Z > PlatformLocation.Z)
		{
			Platform->GetRenderComponent()->SetCollisionResponseToChannel(ECC_Pawn, ECR_Block);
			if (Platform->GetClass()->ImplementsInterface(UPlatformInterface::StaticClass()))
			{
				IPlatformInterface::Execute_TouchAction(Platform,this);
			}
		}
		else
		{
			Platform->GetRenderComponent()->SetCollisionResponseToChannel(ECC_Pawn, ECR_Ignore);
		}
	}
	
}
```

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
至于跳跃，如果是类似跳一跳的游戏，可以在Tick中一直触发跳跃事件，目前来说无伤大雅。
</chatmessage>

![](..%2Fassets%2Fmlao05.png)
