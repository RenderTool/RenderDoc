---
title: NT-3.子系统|网络同步
order: 31
category:
  - unreal
---

<chatmessage avatar=" ../../assets/emoji/hx.png" :avatarWidth="40">
本想着归类到经验或者错误中，不过感觉这个和网络同步模块更加贴切，遗忘时更容易定位回来。
</chatmessage>


## 前置

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
咱们已经清楚所有Character继承自Pawn，Pawn继承自Actor,玩家控制器获取某个Pawn的控制权时，会调用PossessedBy。
</chatmessage>

```cpp
	/** 
	 * Called when this Pawn is possessed. Only called on the server (or in standalone).
	 * @param NewController The controller possessing this pawn
	 */
	virtual void PossessedBy(AController* NewController);
```


### PossessedBy

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
通过源码追溯，PossessedBy接口最早出现在Pawn类中。记住这里的注释 Only called on the server，意味着这个函数
只会在服务器上执行。
</chatmessage>

<chatmessage avatar=" ../../assets/emoji/hx.png" :avatarWidth="40">
那么到底谁会执行PossessedBy？
</chatmessage>

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
事实上所有放入场景的Pawn类即便没人去控制也会执行，只不过这时候是AI控制器在代理执行。为了测试我们可以加入以下代码
</chatmessage>


```cpp
void AExorcistHeroCharacter::PossessedBy(AController* NewController)
{
	Super::PossessedBy(NewController);
	UE_LOG(LogTemp, Warning, TEXT("PossessedBy %d"), count);
	InitAbilityActorInfo();
}
```
>InitAbilityActorInfo()中写了计数函数主要负责++处理，以及获取玩家PlayerState

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
然后在场景中运行，不出意外只会打印一次。
</chatmessage>

![](..%2Fassets%2Fnetwork004.png)

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
现在我们在场景中丢个Pawn进去
</chatmessage>

![](..%2Fassets%2Fnetwork005.png)

<chatmessage avatar=" ../../assets/emoji/hx.png" :avatarWidth="40">
为什么会被打印两次？
</chatmessage>

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
因为场景中的Pawn默认会交给AI控制器Possess，而且咱们的代码并没有做控制器类型判断。
</chatmessage>

![](..%2Fassets%2Fnetwork006.jpg)

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
通过禁用控制器也可以验证这一点。
</chatmessage>

![](..%2Fassets%2Fnetwork007.png)

### PlayerState

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
所以PossessedBy处理获取玩家PlayerState的时要额外小心，因为AI是没有PlayerState的，会导致内存异常。
</chatmessage>

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
现在我们考虑客户端加入的情况。
</chatmessage>

![](..%2Fassets%2Fnetwork008.jpg)

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
可以看到主机和客户端各自都会执行一次自己的PossessBy
</chatmessage>

### OnRep_PlayerState

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
有意思的来了，OnRep_PlayerState被执行了多少次？
</chatmessage>

```cpp
void AExorcistHeroCharacter::OnRep_PlayerState()
{
	Super::OnRep_PlayerState();
	UE_LOG(LogTemp, Warning, TEXT("OnRep_PlayerState %d"), count);
	InitAbilityActorInfo();
}
```

<chatmessage avatar=" ../../assets/emoji/hx.png" :avatarWidth="40">
看到我头皮发麻，所以到底执行了几次？
</chatmessage>

![](..%2Fassets%2Fnetwork009.png)

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
虽然我们使用了计数也可以配合C++Debug程序，但这种多玩家的情况还是借助引擎蓝图比较靠谱。
所以我们干脆公开计数变量，看看各自的Character中都执行了几次。
</chatmessage>

```cpp
	UPROPERTY(EditAnywhere,BlueprintReadWrite)
	int32 count = 0
```
![](..%2Fassets%2Fnetwork010.jpg)

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
可以无论是客户端还是服务器，各自拥有的Character都执行了一次OnRep_PlayerState();
</chatmessage>

<gifwithbutton src="../../assets/unrealgif/hpup06.gif"/>

### 子系统

<chatmessage avatar=" ../../assets/emoji/hx.png" :avatarWidth="40">
问题来了，如果我们把逻辑写在管理类中比如子系统中，它会被执行几次？
</chatmessage>

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
子系统并不像HUD那样被限制在客户端本地执行，我们可以传入一些变量到我们的子系统中，看看最终赋值情况
</chatmessage>


```cpp
void AExorcistHeroCharacter::InitAbilityActorInfo()
{
	UExorcistAbilitySubsystem* ExorcistAbilitySubsystem = UGameplayStatics::GetGameInstance(this)->GetSubsystem<UExorcistAbilitySubsystem>();
	ExorcistAbilitySubsystem->InitOverlay(AbilitySystemComponent, AttributeSet);
	ExorcistAbilitySubsystem->BroadCastInitialValues();
}
```
<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
虽然子系统本身是不会进行网络同步的，我们可以在子系统中也加入引用计数。
其实不用调试也能猜到，子系统中AbilitySystemComponent和AttributeSet会被覆盖成最后一个玩家的数据，
</chatmessage>

<chatmessage avatar=" ../../assets/emoji/hx.png" :avatarWidth="40">
可是为什么玩家A的血条扣了以后，所有玩家的血条都口血了？
</chatmessage>

<gifwithbutton src="../../assets/unrealgif/hpup08.gif"/>

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
你在子系统中是不是写了委托转发？当AbilitySystemComponent和AttributeSet覆盖成新值时，原本的委托并没有解
绑，他会继续绑定新的委托。
</chatmessage>

![](..%2Fassets%2Fnetwork011.jpg)


<chatmessage avatar=" ../../assets/emoji/hx.png" :avatarWidth="40">
难怪我玩家A的血条一扣，所有玩家的HUD血条也跟着扣，但其实这个血量并不是玩家B自己的，而是玩家A的。。
</chatmessage>


<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
借助蓝图调试可以进一步验证这点
</chatmessage>

<gifwithbutton src="../../assets/unrealgif/hpup09.gif"/>


<chatmessage avatar=" ../../assets/emoji/hx.png" :avatarWidth="40">
那该怎么解决呢？
</chatmessage>

### 解决思路1:

<chatmessage avatar="../../assets/emoji/bqb (2).png" :avatarWidth="40" alignLeft>
按照单一职责原则，某个类不应该有过多的逻辑限制其他使用者，比如判断是不是本地玩家，子系统并不关心使用者是谁。
通过IsLocallyControlled可以判断是不是本地玩家,简单高效。
</chatmessage>

```cpp
if (IsLocallyControlled())
{
		//调用子系统，利用子系统转发GE委托或者能力等
    	UExorcistAbilitySubsystem* ExorcistAbilitySubsystem = UGameplayStatics::GetGameInstance(this)->GetSubsystem<UExorcistAbilitySubsystem>();

		if(!ExorcistAbilitySubsystem)
		{
			return;
		}
		//子系统初始化组件，并将初始GE加载显示。
		ExorcistAbilitySubsystem->InitOverlay(AbilitySystemComponent, AttributeSet);
		ExorcistAbilitySubsystem->BroadCastInitialValues();
	
}
```